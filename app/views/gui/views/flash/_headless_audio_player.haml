- push( headless_audio_player )

-# This is a adapted from adam's player
%div[_]{ :data=>{'jsclass'=>'HeadlessAudioplayer', 'autoplay'=>'false', 'preload'=>'true'} }
	- link_to _.mp3Url do
		play


-# it would be nice if we didnt have to repeat this everywhere
:javascript
	#{_.varName}_json = #{_.jsonProperties}


- if( _.includeOnce? )
	:javascript

		HooKVOTests = SC.Object.extend({
		  showFullName: NO,
		  sendChangesToServer: function(key) {
			// ... send changes to the server
			// alert("This really works");
		  }.observes('showFullName'),

		  readyState: function( arg ) {
			alert("woo woo mutha fucker");
		  }
		});
		var kvoTest = HooKVOTests.create();
		kvoTest.set('showFullName', YES);

		// flashPlayerInstance.addObserver('ready', kvoTest.readyState );

		/*
		 *
		*/
		FlashPlayerBackend = SC.Object.extend({

			_swfSrc: 'http://0.0.0.0:3000/flash/HeadlessPlayer/lib/Debug/headlessPlayer.swf',

			init: function( /* init never has args */ ) {

				// var self=this;
				// self.observable = this;

				// getters
				// $.each(['readyState', 'duration'], function(i, reader){
				//  self[reader] = function(){return self.player['_'+reader]();};
				//});
				// getters/setters
				// $.each(['src', 'currentTime', 'volume'], function(i, reader){
				// var writer = "set"+reader.charAt(0).toUpperCase()+reader.slice(1);
				// if (!self[reader]) self[reader] = function(){return self.player['_'+reader]();};
				// if (!self[writer]) self[writer] = function(value){return self.player['_'+writer](value);};
				// });

				// if (!this.player.didFinishLaunching || !this.player.didFinishLaunching())  // wait until flash loads before calling functions on it
				//wrapFunctionsUntilEvent(this, ['setSrc', 'play', 'pause'], 'ready');

				// $(self.observable).bind('ended', function(){self.playing=false;});
				// var oldPlay = self.play;
				// var loadChecker;
				// Wrap the play function to show a warning if Flash hasn't loaded yet.
				// self.play = function(callback){
				// if (callback) {
				// return oldPlay.call(self, callback);
				// }
				// if (self.player._buffered == undefined) {
				// var popup = showPopupMessage("Please enable <a href='http://get.adobe.com/flashplayer'>Flash</a> to play audio", 'error');
				// clearInterval(loadChecker);
				// loadChecker = setInterval(function(){
				// if (self.player._buffered != undefined) {
				// popup.dismiss();
				// oldPlay.call(self);
				// clearInterval(loadChecker);
				// }
				// }, 100);
				// } else {
				// oldPlay.call(self);
				// }
				// };
			},

			// Stick the swf at the end of the page
			_attachToPage: function() {

				var $wrapper = $("<div class='booPlayerHolder'/>").appendTo(document.body);
				if( !HeadlessPlayerSingleton.FlashPlayerId )
					HeadlessPlayerSingleton.FlashPlayerId = 0;
				HeadlessPlayerSingleton.FlashPlayerId++;
				var playerId = "booPlayer"+HeadlessPlayerSingleton.FlashPlayerId;
				// IE doesn't like you playing with <object>s once they're created, hence the huge string blob & using innerHTML
				var objectTag = "<object data='"+this._swfSrc+"' id='"+playerId+"' type='application/x-shockwave-flash' width=10 height=10>"+
				 "<param name='movie' value='"+this._swfSrc+"'/><param name='allowScriptAccess' value='always'/><param name='FlashVars' value='rootID="+playerId+"'/></object>";
				if($.browser.msie)
					$wrapper[0].innerHTML = objectTag;
				else
					$wrapper.append(objectTag);
				return $wrapper.find('object')[0];
			},

			buffered: function(){
			// var buffered = this.player._buffered();
			// return buffered && buffered[0][1] / this.duration();
			},

			ready: function(callback) {
			// var self = this;
			// if (self.player.didFinishLaunching && self.player.didFinishLaunching())
			// callback.apply(self);
			// else
			//   $(self.observable).bind('ready', function(){callback.apply(self);});
			},

			setCurrentTime: function(value) {
			// this.player._setCurrentTime(value);
			// Immediately trigger a timeupdate event because flash is quite slow to fire this on its own
			// $(this.observable).trigger('timeupdate');
			},

			// the flash player gets pretty upset at us calling pause twice in a row, and loses its playback point
			// try and keep track of whether we're already paused before calling pause again:
			play: function(callback) {
			// if (callback)
			//  return $(this.observable).bind('play',callback);
			// if (!this.playing) {
			//  this.playing = true;
			//  this.player._play();
			//}
			return this;
			},

			pause: function(callback) {
			// if (callback)
			// return $(this.observable).bind('pause',callback);
			// if (this.playing) {
			//   this.playing = false;
			//   this.player._pause();
			// }
			return this;
			},
		});






		HTMLPlayerBackend = SC.Object.extend({

			init: function( /* init never has args */ ) {
				// var self=this;
				// self.observable = self.player;

				// functions
				//$.each(['play', 'pause'], function(i, fn){
				//  self[fn] = function(callback){
				//	return callback ? $(self.observable).bind(fn,callback) : self.player[fn]();
				//  };
				//});
				// getters
				//$.each(['readyState', 'duration'], function(i, reader){
				//  self[reader] = function(){return self.player[reader];};
				//});
				// getters/setters
				//$.each(['src', 'currentTime', 'volume'], function(i, reader){
				//  var writer = "set"+reader.charAt(0).toUpperCase()+reader.slice(1);
				//  if (!self[writer]) self[reader] = function(){return self.player[reader];};
				//  if (!self[writer]) self[writer] = function(value){return self.player[reader]=value;};
				//});
			  },

			// stick the audio element at the end of the page
			_attachToPage: function() {

				var audioElem = document.createElement('audio');
				var $wrapper = $("<div class='booPlayerHolder'/>").appendTo(document.body);
			  	$wrapper.append(audioElem);
			  	return audioElem;
			},

		  buffered: function() {
			if (!this.player.buffered)
			  return 0;
			// Discount the possibility of multiple buffers for now (theoretically possible with range requests if the user skips forward, but Safari doesn't seem to support it)
			// and just return the proportion of buffered time
			var buffers = this.player.buffered.length;
			return buffers ? this.player.buffered.end(buffers-1)/this.player.duration : 0;
		  },

		  ready: function(callback) {
			// html5 audio is always ready
			callback.apply(this);
		  },

		  setSrc: function(value) {
			if (!value)
			  debugger;
			if (this.player.currentSrc==value)
			  return;
			this.player.src = value;
			this.player.load(); // force the audio to reset & start loading the new url
		  }

		});




		/*
		 * we attach one swf/audio element to the page
		*/
		HeadlessPlayerSingleton = SC.Object.extend({

			_playerBackend: undefined,

			init: function( /* init never has args */ ) {
				arguments.callee.base.apply(this,arguments);
				this._attachAudioPlayerToPage();
			},

			_attachAudioPlayerToPage: function() {

				var browserHasNativeMp3Support = browserCanPlayNativeMP3();
				var browserHasFlash = hasMinimumFlash();
				var useNativePlayback = browserHasNativeMp3Support && !browserIsSafari();
				// flash may be blocked, but we still report that we have it
				if( !useNativePlayback && !browserHasFlash )
					throw("boo.oldflasherror");

				this._playerBackend = useNativePlayback ? HTMLPlayerBackend.create() : FlashPlayerBackend.create();
				this._playerBackend._attachToPage();

				// this._player = useNativePlayback ? this._attachAudioElement( $wrapper ) : this._attachHeadlessFlashPlayer( $wrapper );
				// this._playerType = useNativePlayback ? HTMLPlayer : FlashPlayer;

				// Add a data attribute to map from the DOM player back to our AudioPlayer object
				// However, we can't use data() on <object> tags (see jQuery.noData), so it'll have to go on the parent wrapper
				// if($(this._player).parent().data('booPlayer'))
				//	throw("Already added a player to wrapper node");
				// $(this._player).parent().data('booPlayer', this);
			},




		});


		/*
		 * We can create an instance of this for each audio clip
		*/
		HeadlessAudioplayer = HooWidget.extend({

			ready: undefined,

			init: function( /* init never has args */ ) {
				arguments.callee.base.apply(this,arguments);
				this.ready = false;
				if( HeadlessAudioplayer.sharedHeadlessPlayerSwf==undefined ){
					try {
						HeadlessAudioplayer.sharedHeadlessPlayerSwf = HeadlessPlayerSingleton.create();
					} catch(err) {
			 			 $(this).trigger('booError', err);
			  			alert("install flash dufus "+err);
			  			return;
			  		}
				}
			},
		});






		// Wrap 1 or more functions of an object to delay them until a given event fires
		// Once that event fires, the functions trigger immediately if they're called again.
		function wrapFunctionsUntilEvent(object, functions, eventName) {
		  object.__wrappedMethods = {};
		  $.each(functions, function(){
			var methodName = this;
			var originalMethod = object[methodName];
			object.__wrappedMethods[methodName] = originalMethod;
			object[methodName] = function(){
			  var originalArguments = arguments;
			  $(object).one(eventName, function(){
				originalMethod.apply(object, originalArguments);
			  });
			};
		  });
		  $(object).one(eventName, function() {
			$.extend(object, object.__wrappedMethods);
			delete object.__wrappedMethods;
		  });
		}




		/* Flash Callback */
		function BooFlashPlayerEvent( id, eventName, optionArg1 ) {
		  var player = $("#"+id).parent().data('booPlayer');
		  $(player.observable).triggerHandler(eventName);
		}

		var OldFlashError="boo.oldflasherror";
		// console.error( "Please install <a href='http://get.adobe.com/flashplayer'>Flash 10</a> or above" );

		function formatTime(time) {
		  var minutes = Math.floor(time/60);
		  var seconds = Math.floor(time)%60;
		  return minutes + ':' + (seconds<10 ? '0'+seconds : seconds);
		}
		$.fn.mousedrag = function(callback) {
		  this.mousedown(function(e) {
			callback.apply(this,arguments);
			var activeElement=this;
			var mousePos = [e.pageX, e.pageY];
			$(document.body).bind('mousemove.booDrag', function(e){
			  if ((mousePos[0] == e.pageX)&&(mousePos[1]==e.pageY)) // IE fires mouse events continuously even when it doesn't move more than 1 pixel
				return;
			  mousePos = [e.pageX, e.pageY];
			  callback.apply(activeElement,arguments);
			});
			$(document.body).bind('mouseleave.booDrag mouseup.booDrag', function(){
			  $(document.body).unbind('.booDrag');
			});
			return false; //prevent text selection
		  });
		  this.bind('selectstart', function(e){return false;}); //prevent text selection in IE
		  return this;
		};




- push( headless_audio_player )

-# This is a adapted from adam's player
%div[_]{ :data=>{'jsclass'=>'HeadlessAudioplayer', 'autoplay'=>'false', 'preload'=>'true'} }
	- link_to _.mp3Url do
		play


- if( _.includeOnce? )
	:javascript

		function getPercentProg() {
			console.log("Some progress was made at least");
		}


		/* Flash Callback */
		function BooFlashPlayerEvent( id, eventName, optionArg1 ) {
			FlashPlayerBackend.sharedInstance._flash_callBack( id, eventName, optionArg1 )
		}

		/*
		 *
		*/
		FlashPlayerBackend = SC.Object.extend({

			_swfSrc: 		'http://0.0.0.0:3000/flash/HeadlessPlayer/lib/Debug/headlessPlayer.swf',
			ready:			undefined,
			_embeddedSwf:	undefined,

			init: function( /* init never has args */ ) {
				arguments.callee.base.apply(this,arguments);
				this.ready = false;
				FlashPlayerBackend.sharedInstance = this;

				// if (!this.player.didFinishLaunching || !this.player.didFinishLaunching())  // wait until flash loads before calling functions on it
				//wrapFunctionsUntilEvent(this, ['setSrc', 'play', 'pause'], 'ready');

				// $(self.observable).bind('ended', function(){self.playing=false;});
				// var oldPlay = self.play;
				// var loadChecker;
				// Wrap the play function to show a warning if Flash hasn't loaded yet.
				// self.play = function(callback){
				// if (callback) {
				// return oldPlay.call(self, callback);
				// }
				// if (self.player._buffered == undefined) {
				// var popup = showPopupMessage("Please enable <a href='http://get.adobe.com/flashplayer'>Flash</a> to play audio", 'error');
				// clearInterval(loadChecker);
				// loadChecker = setInterval(function(){
				// if (self.player._buffered != undefined) {
				// popup.dismiss();
				// oldPlay.call(self);
				// clearInterval(loadChecker);
				// }
				// }, 100);
				// } else {
				// oldPlay.call(self);
				// }
				// };
			},

			// Stick the swf at the end of the page
			_attachToPage: function() {

				var $wrapper = $("<div class='booPlayerHolder'/>").appendTo(document.body);
				if( !HeadlessPlayerSingleton.FlashPlayerId )
					HeadlessPlayerSingleton.FlashPlayerId = 0;
				HeadlessPlayerSingleton.FlashPlayerId++;
				var playerId = "booPlayer"+HeadlessPlayerSingleton.FlashPlayerId;
				// IE doesn't like you playing with <object>s once they're created, hence the huge string blob & using innerHTML
				var objectTag = "<object data='"+this._swfSrc+"' id='"+playerId+"' type='application/x-shockwave-flash' width=300 height=300>"+
				 "<param name='movie' value='"+this._swfSrc+"'/><param name='allowScriptAccess' value='always'/><param name='FlashVars' value='rootID="+playerId+"'/></object>";
				if($.browser.msie)
					$wrapper[0].innerHTML = objectTag;
				else
					$wrapper.append(objectTag);
				this._embeddedSwf = $wrapper.find('object')[0];

				// woo woo
				//this._embeddedSwf.addEventListener( "Play", function(e) { 			console.log("PPPPPLLLLLAAAAAYYYYY!!"); }, true);

				$('.booPlayerHolder').bind('foo', { 'bar' : 'bam' }, function(e) { alert(e.data.bar); });
			},

			/* receive events from the swf */
			_flash_callBack: function( id, eventName, optionArg1 ) {

				if( eventName=="ready" ) {
					this.set('ready', YES);
				} else if( eventName=="didSetSrc" ) {
				} else if( eventName=="play" ) {
				} else if( eventName=="progress" ) {
				} else if( eventName=="timeupdate" ) {
				} else if( eventName=="ended" ) {
					// began playing
				} else {
					alert("Unknown callback "+eventName);
				}
			},

			play: function(callback) {
				this._embeddedSwf._play();
			},

			src: function() {
				return this._embeddedSwf._src
			},

			setSrc: function( url ) {
				this._embeddedSwf._setSrc( url );
				this._embeddedSwf._load(); // force the audio to reset & start loading the new url
			},

			buffered: function(){
			// var buffered = this.player._buffered();
			// return buffered && buffered[0][1] / this.duration();
			},

			setCurrentTime: function(value) {
			// this.player._setCurrentTime(value);
			// Immediately trigger a timeupdate event because flash is quite slow to fire this on its own
			// $(this.observable).trigger('timeupdate');
			},

			pause: function(callback) {
			// if (callback)
			// return $(this.observable).bind('pause',callback);
			// if (this.playing) {
			//   this.playing = false;
			//   this.player._pause();
			// }
			return this;
			},
		});


		HTMLPlayerBackend = SC.Object.extend({

			ready:				undefined,
			_audioElement:		undefined,

			init: function( /* init never has args */ ) {
				arguments.callee.base.apply(this,arguments);
				this.ready = false;
			},

			// stick the audio element at the end of the page
			_attachToPage: function() {
				var audioElem = document.createElement('audio');
				var $wrapper = $("<div class='booPlayerHolder'/>").appendTo(document.body);
			  	$wrapper.append(audioElem);
				this.ready = true;				/* html5 was born ready */
			  	this._audioElement = audioElem;

			  	// chrome
			  	// emptied, loadstart, play, waiting, error
			  	// emptied, loadstart, play, waiting, durationchange, loadedmetadat, timeupdate, loadeddata, canplay, canplaythru, timeupdate

			  	// Safari
			  	// loadstart, play, waiting, timeupdate, error
			  	// loadstart, play, waiting, durationchange, loadedmetadata, loadeddata, canplay, canplaythrough

			  	// http://www.w3schools.com/html5/html5_ref_eventattributes.asp
			  	// https://developer.mozilla.org/En/Using_audio_and_video_in_Firefox
			  	var self = this;

				audioElem.addEventListener( "error", function( e ) {
					console.log("Event: error "+e); debugger;
				}, true);

				this._audioElement.addEventListener( "loadstart", function() {
					console.log("Loaded 0");
				}, true);

				/* Progress isnt always called */
				$(audioElem).bind( 'progress', function() {
					console.log("Event: load progress "+self.buffered());
				});

				/* Dont count on the metadata */
				//this._audioElement.addEventListener( "loadedmetadata", function() {
				//	console.log("Event: loadedmetadata "+audioElem.duration);
				//	if(audioElem.duration!=NaN && audioElem.duration!=Infinity)
				//		self.setDuration( audioElem.duration );
				//}, true);

				this._audioElement.addEventListener( "loadeddata", function() {
					console.log("All Loaded "+self.buffered());
				}, true);




				// can play thru is not the same as fully loaded
				this._audioElement.addEventListener( "canplaythrough", function() {
					console.log("Event: canplaythrough "+audioElem.duration);
				}, true);

				audioElem.addEventListener( "canplay", function() { 			console.log("Event: canplay"); }, true);
				audioElem.addEventListener( "abort", function() { 				console.log("Event: abort"); }, true);
				audioElem.addEventListener( "dataunavailable", function() { 	console.log("Event: dataunavailable"); }, true);
				audioElem.addEventListener( "durationchange", function() { 	console.log("Event: durationchange"); }, true);
				audioElem.addEventListener( "emptied", function() { 			console.log("Event: emptied"); }, true);
				audioElem.addEventListener( "empty", function() { 				console.log("Event: empty"); }, true);
				audioElem.addEventListener( "ended", function() { 				console.log("Event: ended"); }, true);
				audioElem.addEventListener( "pause", function() { 				console.log("Event: pause"); }, true);
				audioElem.addEventListener( "play", function() { 				console.log("Event: play"); }, true);
				audioElem.addEventListener( "ratechange", function() { 		console.log("Event: ratechange"); }, true);
				audioElem.addEventListener( "seeked", function() { 			console.log("Event: seeked"); }, true);
				audioElem.addEventListener( "seeking", function() { 			console.log("Event: seeking"); }, true);
				audioElem.addEventListener( "timeupdate", function() { 		console.log("Event: timeupdate"); }, true);
				audioElem.addEventListener( "volumechange", function() { 		console.log("Event: volumechange"); }, true);
				audioElem.addEventListener( "waiting", function() { 			console.log("Event: waiting"); }, true);
			},

			// alert(video.networkState == video.NETWORK_EMPTY); // true
			buffered: function() {
				if (!this._audioElement.buffered)
			  		return 0;
			  	var timeRanges = this._audioElement.buffered;
			  	var endTime = 0;

			  	if( timeRanges.length )
				try {
						// Discount the possibility of multiple buffers for now (theoretically possible with range requests if the user skips forward, but Safari doesn't seem to support it)
						// and just return the proportion of buffered time
						endTime = timeRanges.end(timeRanges.length-1);
				} catch(err) {
					alert(err);
					return 0;
				}
				return endTime;
			},

			play: function() {
				// this._audioElement.autoplay = true;
				//this._audioElement.play();
			},

			src: function() {
				return this._audioElement.src;
			},

			setSrc: function( url ) {
				if (!url) debugger;
				this._audioElement.src = url;
				// this._audioElement.type = 'audio/mpeg';
				// this._audioElement.preload = "auto";
				this._audioElement.load(); // force the audio to reset & start loading the new url
			},

		});


		/*
		 * we attach one swf/audio element to the page
		*/
		HeadlessPlayerSingleton = SC.Object.extend({

			_playerBackend: undefined,
			_activePlayer:undefined,

			init: function( /* init never has args */ ) {
				arguments.callee.base.apply(this,arguments);
				this._attachAudioPlayerToPage();
			},

			_attachAudioPlayerToPage: function() {

				var browserHasNativeMp3Support = browserCanPlayNativeMP3();
				var browserHasFlash = hasMinimumFlash();
				var useNativePlayback = browserHasNativeMp3Support; // && !browserIsSafari();
				// flash may be blocked, but we still report that we have it
				if( !useNativePlayback && !browserHasFlash )
					throw("boo.oldflasherror");

				this._playerBackend = useNativePlayback ? HTMLPlayerBackend.create() : FlashPlayerBackend.create();
				this._playerBackend._attachToPage();
			},

			whenReady: function( target, callBack ) {
				if(this._playerBackend.ready) {
					callBack.apply(target);
				} else {
					console.log("not already ready "+ target);
					this._playerBackend.addObserver( 'ready', target, callBack );// !grr kinda leaking this
				}
			},

			reset: function() {

			},

			playerBecameCurrent: function( playerInstance ) {
				if(playerInstance!=this._activePlayer){
					this.reset();
					this.set('_activePlayer', playerInstance);
				}
			},

			play: function( mp3Url ) {
				if( mp3Url!=this._playerBackend.src )
					this._playerBackend.setSrc(mp3Url); // wait?
				this._playerBackend.play();
			}

		});


		/*
		 * We can create an instance of this for each audio clip
		 * We need to bind the spinners and progress to this, not the singleton
		 * If we had 100 in a page when would we set up bindings?
		*/
		HeadlessAudioplayer = HooWidget.extend({

			ready:	undefined,
			_src:	undefined,

			init: function( /* init never has args */ ) {
				arguments.callee.base.apply(this,arguments);
				this.ready = false;
				if( HeadlessAudioplayer.sharedHeadlessPlayer==undefined ){
					try {
						HeadlessAudioplayer.sharedHeadlessPlayer = HeadlessPlayerSingleton.create();
					} catch(err) {
			 			 $(this).trigger('booError', err);
			  			alert("install flash dufus "+err);
			  			return;
			  		}
				}

				if( this.json.mp3Url ) {
					this._src = this.json.mp3Url;
					HeadlessAudioplayer.sharedHeadlessPlayer.whenReady( this, this.didBecomeReady );
				}
			},

			// we should be observing this
			didBecomeReady: function(){
				this.set( "ready", YES );
			},

			play: function(){
				//TODO: Where do we check that the mp3 exits?
				HeadlessAudioplayer.sharedHeadlessPlayer.playerBecameCurrent(this);
				HeadlessAudioplayer.sharedHeadlessPlayer.play( this._src );
			},
		});


		// woah trigger() is fucking cool man
		// we should definitely, like, use it
		function printPlayerInfos() {
			$.each( HeadlessAudioplayer.players, function( index, value ){
				console.log( "Player "+value+" :type "+value.type+
					"url "+value.src+
					"playCount "+value.playCount
				);
			});
		}



		// Wrap 1 or more functions of an object to delay them until a given event fires
		// Once that event fires, the functions trigger immediately if they're called again.
		function wrapFunctionsUntilEvent(object, functions, eventName) {
		  object.__wrappedMethods = {};
		  $.each(functions, function(){
			var methodName = this;
			var originalMethod = object[methodName];
			object.__wrappedMethods[methodName] = originalMethod;
			object[methodName] = function(){
			  var originalArguments = arguments;
			  $(object).one(eventName, function(){
				originalMethod.apply(object, originalArguments);
			  });
			};
		  });
		  $(object).one(eventName, function() {
			$.extend(object, object.__wrappedMethods);
			delete object.__wrappedMethods;
		  });
		}






		var OldFlashError="boo.oldflasherror";
		// console.error( "Please install <a href='http://get.adobe.com/flashplayer'>Flash 10</a> or above" );

		function formatTime(time) {
		  var minutes = Math.floor(time/60);
		  var seconds = Math.floor(time)%60;
		  return minutes + ':' + (seconds<10 ? '0'+seconds : seconds);
		}
		$.fn.mousedrag = function(callback) {
		  this.mousedown(function(e) {
			callback.apply(this,arguments);
			var activeElement=this;
			var mousePos = [e.pageX, e.pageY];
			$(document.body).bind('mousemove.booDrag', function(e){
			  if ((mousePos[0] == e.pageX)&&(mousePos[1]==e.pageY)) // IE fires mouse events continuously even when it doesn't move more than 1 pixel
				return;
			  mousePos = [e.pageX, e.pageY];
			  callback.apply(activeElement,arguments);
			});
			$(document.body).bind('mouseleave.booDrag mouseup.booDrag', function(){
			  $(document.body).unbind('.booDrag');
			});
			return false; //prevent text selection
		  });
		  this.bind('selectstart', function(e){return false;}); //prevent text selection in IE
		  return this;
		};




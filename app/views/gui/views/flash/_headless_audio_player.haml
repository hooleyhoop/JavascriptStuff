- push( headless_audio_player )

-# This is a adapted from adam's player
-# http://0.0.0.0:3000/widgets/headlessPlayer
-# http://0.0.0.0:3000/widgets/detailPlayer?url=http://audioboo.fm/boos/313426-the-rose.mp3
-# http://0.0.0.0:3000/widgets/detailPlayer?url=http://audioboo.fm/boos/305019-taking-frank-to-the-vet.mp3
-# http://0.0.0.0:3000/widgets/detailPlayer?url=http://audioboo.fm/boos/197170.mp3
%div[_]{ :data=>{'jsclass'=>'HeadlessAudioplayer', 'autoplay'=>'false', 'preload'=>'true'} }
	.flash_holder( style="width:50px; height:50px; background-color:#00ffff;")

	- link_to( _.mp3Url, {:style =>"position:absolute; left:-1000px;"} ) do
		play

-# http://www.whatwg.org/specs/web-apps/current-work/multipage/video.html#event-media-emptied
- if( _.includeOnce? )
	:javascript

		AudioPlayerState = SC.Object.extend({

			_loadingController: undefined,
			_playingController: undefined,
			_controller:undefined,

			init: function( /* init never has args */ ) {
				arguments.callee.base.apply( this, arguments );

				//set on init - this._controller = controller;

				/* Loading States */
				var l_empty_state			= HooStateMachine_state.create( {name: "empty"} );
				var l_stalled_state			= HooStateMachine_state.create( {name: "stalled"} );
				var l_loading_state			= HooStateMachine_state.create( {name: "loading"} );
				var l_loaded_state			= HooStateMachine_state.create( {name: "loaded"} );
				var l_resetting_state		= HooStateMachine_state.create( {name: "resseting"} );
				var l_error_state			= HooStateMachine_state.create( {name: "error"} );

				/* Shared input events */
				var error_event				= HooStateMachine_event.create( {name: "error"} );
				var reset_event				= HooStateMachine_event.create( {name: "reset"} );

				/* Loading input events */
				var load_event				= HooStateMachine_event.create( {name: "load"} );
				var loadComplete_event		= HooStateMachine_event.create( {name: "loadComplete"} );
				var resetComplete_event		= HooStateMachine_event.create( {name: "resetComplete"} );
				var stall_event				= HooStateMachine_event.create( {name: "stall"} );

				/* Loading transitions */
				l_empty_state.addTransition( load_event, l_loading_state );

				l_loading_state.addTransition( stall_event, l_stalled_state );
				l_loading_state.addTransition( error_event, l_error_state );
				l_loading_state.addTransition( loadComplete_event, l_loaded_state );
				l_loading_state.addTransition( reset_event, l_resetting_state );

				l_stalled_state.addTransition( load_event, l_loading_state );
				l_stalled_state.addTransition( error_event, l_error_state );
				l_stalled_state.addTransition( reset_event, l_resetting_state );

				l_loaded_state.addTransition( reset_event, l_resetting_state );
				l_empty_state.addTransition( reset_event, l_resetting_state );
				l_error_state.addTransition( reset_event, l_resetting_state );

				l_resetting_state.addTransition( resetComplete_event, l_empty_state );

				/* Commands */
				var showEmptyLoaderCmd	 			= HooStateMachine_command.create( {name: "showEmptyLoaderCmd"} );
				var showStalledLoaderCmd	 		= HooStateMachine_command.create( {name: "showStalledLoaderCmd"} );
				var showLoadingLoaderCmd	 		= HooStateMachine_command.create( {name: "showLoadingLoaderCmd"} );
				var showFinishedLoaderCmd	 		= HooStateMachine_command.create( {name: "showFinishedLoaderCmd"} );
				var showResettingLoaderCmd	 		= HooStateMachine_command.create( {name: "showResettingLoaderCmd"} );
				var showErrorLoaderCmd	 			= HooStateMachine_command.create( {name: "showErrorLoaderCmd"} );

				/* Loading actions */
				l_empty_state.addEntryAction( showEmptyLoaderCmd );
				l_stalled_state.addEntryAction( showStalledLoaderCmd );
				l_loading_state.addEntryAction( showLoadingLoaderCmd );
				l_loaded_state.addEntryAction( showFinishedLoaderCmd );
				l_resetting_state.addEntryAction( showResettingLoaderCmd );
				l_error_state.addEntryAction( showErrorLoaderCmd );

				var loadingStateMachine = HooStateMachine.create( {startState: l_empty_state} );
				this._loadingController = HooStateMachine_controller.create( { currentState: l_empty_state, machine: loadingStateMachine, commandsChannel: this } );


				/* Playing States */
				var p_empty_state				= HooStateMachine_state.create( {name: "empty"} );
				var p_stopped_state				= HooStateMachine_state.create( {name: "stopped"} );
				var p_waiting_state				= HooStateMachine_state.create( {name: "waiting"} );
				var p_playing_state				= HooStateMachine_state.create( {name: "playing"} );
				var p_finished_state			= HooStateMachine_state.create( {name: "finished"} );
				var p_error_state				= HooStateMachine_state.create( {name: "error"} );

				/* Playing input events */
				var canPlay_event				= HooStateMachine_event.create( {name: "canPlay"} );
				var play_event					= HooStateMachine_event.create( {name: "play"} );
				var timeupdate_event			= HooStateMachine_event.create( {name: "timeupdate"} );
				var wait_event					= HooStateMachine_event.create( {name: "wait"} );
				var stop_event					= HooStateMachine_event.create( {name: "stop"} );
				var ended_event					= HooStateMachine_event.create( {name: "ended"} );

				/* Playing transitions */
				p_empty_state.addTransition( canPlay_event, p_stopped_state );
				p_empty_state.addTransition( error_event, p_error_state );
				p_empty_state.addTransition( play_event, p_playing_state );

				p_stopped_state.addTransition( play_event, p_playing_state );
				p_stopped_state.addTransition( error_event, p_error_state );
				p_stopped_state.addTransition( reset_event, p_empty_state );

				p_playing_state.addTransition( error_event, p_error_state );
				p_playing_state.addTransition( stop_event, p_stopped_state );
				p_playing_state.addTransition( reset_event, p_empty_state );
				p_playing_state.addTransition( wait_event, p_waiting_state );
				p_playing_state.addTransition( ended_event, p_finished_state );

				// so the idea of hierachical state machine is just that events bubble up the chain

				p_waiting_state.addTransition( error_event, p_error_state );
				p_waiting_state.addTransition( stop_event, p_stopped_state );
				p_waiting_state.addTransition( timeupdate_event, p_playing_state );
				p_waiting_state.addTransition( reset_event, p_empty_state );

				p_finished_state.addTransition( stop_event, p_stopped_state );
				p_error_state.addTransition( reset_event, p_empty_state );

				/* Play commands */
				var showEmptyPlayerCmd	 			= HooStateMachine_command.create( {name: "showEmptyPlayerCmd"} );
				var showStoppedPlayerCmd	 		= HooStateMachine_command.create( {name: "showStoppedPlayerCmd"} );
				var showWaitingPlayerCmd	 		= HooStateMachine_command.create( {name: "showWaitingPlayerCmd"} );
				var hideWaitingPlayerCmd	 		= HooStateMachine_command.create( {name: "hideWaitingPlayerCmd"} );

				var showPlayingPlayerCmd	 		= HooStateMachine_command.create( {name: "showPlayingPlayerCmd"} );
				var showFinishedPlayerCmd	 		= HooStateMachine_command.create( {name: "showFinishedPlayerCmd"} );
				var showErrorPlayerCmd	 			= HooStateMachine_command.create( {name: "showErrorPlayerCmd"} );

				/* Playing actions */
				p_empty_state.addEntryAction( showEmptyPlayerCmd );
				p_stopped_state.addEntryAction( showStoppedPlayerCmd );
				p_waiting_state.addEntryAction( showWaitingPlayerCmd );
				p_waiting_state.addExitAction( hideWaitingPlayerCmd );

				p_playing_state.addEntryAction( showPlayingPlayerCmd );
				p_finished_state.addEntryAction( showFinishedPlayerCmd );
				p_error_state.addEntryAction( showErrorPlayerCmd );


				var playingStateMachine = HooStateMachine.create( {startState: p_empty_state} );
				this._playingController = HooStateMachine_controller.create( { currentState: p_empty_state, machine: playingStateMachine, commandsChannel: this } );
			},

			 send: function( command ) {
			 	var func = this._controller[command.name];
			 	if(func) {
					func.call(this._controller);
				} else {
					console.log("Didnt find function "+command.name);
				}

				// tHere is one 'special' case
				if(command.name=="showResettingLoaderCmd") {
					// -- this has to manually trigger complete
					this._loadingController.handle( "resetComplete" );
				}
			},

			processInputSignal: function( signal ) {
				// console.log("Incoming >> "+signal );
				switch( signal ){
					case "ready":
						this._controller.ready();
						break;

					// not really sure of the purpose of abort
					case "abort":
						break;

					case "error":
					case "dataunavailable":
					case "empty":
						this._loadingController.handle( "error" );
						this._playingController.handle( "error" );
						break;

					case "stalled":
						this._loadingController.handle( "stall" );
						break;

					case "waiting":
						this._playingController.handle( "wait" );
						break;

					case "loadstart":
					case "loadedmetadata":
						this._loadingController.handle( "load" );
						break;
					case "durationchange":
						this._loadingController.handle( "load" );
						this._controller.durationchange();
						break;
					case "progress":
						this._loadingController.handle( "load" );
						this._controller.progressupdate();
						break;

					case "canplay":
					case "canplaythrough":
						this._loadingController.handle( "load" );
						this._playingController.handle( "canPlay" );
						break;

					case "loadeddata":
						this._loadingController.handle( "loadComplete" );
						break;

					case "emptied":
						this._loadingController.handle( "reset" );
						this._playingController.handle( "reset" );
						break;

					case "timeupdate":
						this._playingController.handle( "timeupdate" );
						this._controller.timeupdate();
						break;

					case "play":
						this._playingController.handle( "play" );
						break;

					case "ended":
						this._playingController.handle( "ended" );
						break;

					case "pause":
						this._playingController.handle( "stop" );
						break;

					default:
						throw("** Unknown Signal ** -"+signal);
				}
			}
		});

		/*
		 *
		*/
		AbstractPlayerBackend = SC.Object.extend({

			_observablePlayer: undefined,
			_commandablePlayer: undefined,
			ready:				undefined,

			init: function( /* init never has args */ ) {
				arguments.callee.base.apply(this,arguments);
				this.ready = false;
			},

			play: function(callback) {
				this._commandablePlayer.setAttribute( 'autoplay', true );
				this._commandablePlayer.play();
			},

			src: function() {
				return this._commandablePlayer.getAttribute( 'src' );
			},

			setSrc: function( url ) {
				if (!url) debugger;
				this._commandablePlayer.setAttribute( 'src', url );
				// this._commandablePlayer.type = 'audio/mpeg';
				// this._commandablePlayer.preload = "auto";
				this._commandablePlayer.load(); // force the audio to reset & start loading the new url
			},

			duration: function() {
			  	return this._commandablePlayer.getNodeProperty('duration');
			},

			setCurrentTime: function(value) {
				this._commandablePlayer.setNodeProperty( 'currentTime', value );
			},

			// alert(video.networkState == video.NETWORK_EMPTY); // true
			buffered: function() {

			  	var timeRanges = this._commandablePlayer.getNodeProperty('buffered');
			  	if(!timeRanges){
			  		console.log("Buffered attribute NOT found");
			  		return 0;
			  	}
			  	var endTime = 0;

			  	if( timeRanges.length )
				try {
					// Discount the possibility of multiple buffers for now (theoretically possible with range requests if the user skips forward, but Safari doesn't seem to support it)
					// and just return the proportion of buffered time
					var timeRangeIndex = timeRanges.length-1;
					endTime = this._getTimeRangeEnd( timeRanges, timeRangeIndex ); // implemented differently for flash and html5
				} catch(err) {
					alert(err);
					return 0;
				}
				return endTime;
			}
		});

		/*
		 *
		*/
		FlashPlayerBackend = AbstractPlayerBackend.extend({

			_swfSrc: 		'http://0.0.0.0:3000/flash/HeadlessPlayer/lib/Debug/HeadlessPlayer.swf',
			_embeddedSwf:	undefined,
			type:			"Flash",

			init: function( /* init never has args */ ) {
				arguments.callee.base.apply(this,arguments);
				FlashPlayerBackend.sharedInstance = this;
			},

			// Stick the swf at the end of the page
			_attachToPage: function() {

				var $wrapper = $("<div class='booPlayerHolder'/>").appendTo(document.body);
				if( !HeadlessPlayerSingleton.FlashPlayerId )
					HeadlessPlayerSingleton.FlashPlayerId = 0;
				HeadlessPlayerSingleton.FlashPlayerId++;
				var playerId = "booPlayer"+HeadlessPlayerSingleton.FlashPlayerId;

				var attemptSillyCacheFoil = YES;
				var foilString = attemptSillyCacheFoil ? "?"+encodeURIComponent(new Date().toUTCString()) : "";

				// IE doesn't like you playing with <object>s once they're created, hence the huge string blob & using innerHTML
				var objectTag = "<object data='"+this._swfSrc+foilString+"' id='"+playerId+"' type='application/x-shockwave-flash' width=50 height=50>"+
				 "<param name='movie' value='"+this._swfSrc+"'/><param name='allowScriptAccess' value='always'/><param name='FlashVars' value='rootID="+playerId+"'/></object>";
				if($.browser.msie)
					$wrapper[0].innerHTML = objectTag;
				else
					$wrapper.append(objectTag);
				this._embeddedSwf = $wrapper.find('object')[0];

				this._observablePlayer = $wrapper;
				this._commandablePlayer = this._embeddedSwf;

				// Hack in some utility functions to make sure audio element has the same interface as the swf
				this._commandablePlayer.getNodeProperty = function(propertyName){ return this[propertyName](); };
				this._commandablePlayer.setNodeProperty = function(propertyName,value){ this['set'+propertyName](value); };

				var self = this;
				$wrapper.bind('ready', function(){ self.set('ready', YES); })
			},

			_getTimeRangeEnd: function( timeRanges, timeRangeIndex ) {
				return timeRanges[timeRangeIndex][1];
			}
		});


		HTMLPlayerBackend = AbstractPlayerBackend.extend({

			type:				"HTML5",
			_audioElement:		undefined,

			init: function( /* init never has args */ ) {
				arguments.callee.base.apply(this,arguments);
				this.ready = false;
			},

			// stick the audio element at the end of the page
			_attachToPage: function() {
				var audioElem = document.createElement('audio');
				var $wrapper = $("<div class='booPlayerHolder'/>").appendTo(document.body);
			  	$wrapper.append(audioElem);
				this.ready = true;				/* html5 was born ready */
			  	this._audioElement = audioElem;

				// in flash the object i observe is different than the object we command, hence this
				this._observablePlayer = this._audioElement;
				this._commandablePlayer = this._audioElement;

				// Hack in some utility functions to make sure audio element has the same interface as the swf
				this._commandablePlayer.getNodeProperty = function(propertyName){ return this[propertyName] };
				this._commandablePlayer.setNodeProperty = function(propertyName,value){ this[propertyName]=value };
			},

			_getTimeRangeEnd: function( timeRanges, timeRangeIndex ) {
				timeRanges.end(timeRangeIndex);
			}

		});


		/*
		 * we attach one swf/audio element to the page
		*/
		HeadlessPlayerSingleton = SC.Object.extend({

			_playerBackend: undefined,	// flash or HTML5
			_activePlayer: undefined,	// the current instance using the singleton
			_stateMachine: undefined,

			init: function( /* init never has args */ ) {
				arguments.callee.base.apply(this,arguments);
				this.stateMachine = AudioPlayerState.create( {_controller: this} );
				this._attachFlashOrHtml5AudioPlayerToPage();
			},

			_attachFlashOrHtml5AudioPlayerToPage: function() {

				var browserHasNativeMp3Support = browserCanPlayNativeMP3();
				var browserHasFlash = hasMinimumFlash();

				var shouldUseFlashInSafari = NO;
				if(shouldUseFlashInSafari)
					isSafari = browserIsSafari();
				else
					isSafari = false;

				var useNativePlayback = browserHasNativeMp3Support && !isSafari;
				// flash may be blocked, but we still report that we have it
				if( !useNativePlayback && !browserHasFlash )
					throw("boo.oldflasherror");

				this._playerBackend = useNativePlayback ? HTMLPlayerBackend.create() : FlashPlayerBackend.create();
				this._playerBackend._attachToPage();

				/* obviously temporary - get it to work with html player first */
				this._createObservervations();
			},

			whenReady: function( target, callBack ) {

				if(this._playerBackend.ready) {
					callBack.apply(target);
				} else {
					console.log("not already ready "+ target);
					this._playerBackend.addObserver( 'ready', target, callBack );// !grr kinda leaking this
				}
			},

			_createObservervations: function(){

				/*
				 * Example sequences of events
				 * (bare in mind that this was done with local mp3 files, which is broken)
				 */

			  	// chrome
			  	// emptied, loadstart, play, waiting, error
			  	// emptied, loadstart, play, waiting, durationchange, loadedmetadata, timeupdate, loadeddata, canplay, canplaythru, timeupdate, timeupdate, ended

			  	// Safari
			  	// loadstart, play, waiting, timeupdate, error
			  	// loadstart, play, waiting, durationchange, loadedmetadata, loadeddata, canplay, canplaythrough, timeupdate, ended
				// NB, safari doesn't send an emptied event if we swap out the url

				// Firefox
				// -- -- -- -- -- -- -- --
				// TODO

				// FlashPlayer
				// -- -- -- -- -- -- -- --
				// TODO

			  	// http://www.w3schools.com/html5/html5_ref_eventattributes.asp
			  	// https://developer.mozilla.org/En/Using_audio_and_video_in_Firefox
			  	var self = this;
				var $actualPlayer = $(this._playerBackend._observablePlayer);

				var watchableEvents = 'error emptied loadstart progress loadeddata loadedmetadata durationchange timeupdate canplay canplaythrough waiting play ended abort dataunavailable empty pause ratechange seeked seeking volumechange stalled';
				$actualPlayer.bind( watchableEvents, function( e ) {
					self.handlePlayerEvent(e.type);
				});
			},

			reset: function() {
			},

			playerBecameCurrent: function( playerInstance ) {
				if(playerInstance!=this._activePlayer){
					this.reset();
					this.set('_activePlayer', playerInstance);
					this.stateMachine._controller = playerInstance._controller;
				}
			},

			handlePlayerEvent: function( eventName ) {
				this.stateMachine.processInputSignal( eventName );
			},

			play: function( mp3Url ) {
				if( mp3Url!=this._playerBackend.src ) {
					this._playerBackend.setSrc(mp3Url); // wait? for async callback?
				}
				this._playerBackend.play();


				// DEBUG
				// DEBUG
				// DEBUG THING TO FAKE EVENTS
				// temp time test
				var self = this;
				var timerID = window.setTimeout( function(){
					// self._playerBackend.setCurrentTime(0);
					// self._playerBackend.setSrc("http://audioboo.fm/boos/305019-taking-frank-to-the-vet.mp3");
				 }, 4000);
			}
		});


		/*
		 * We can create an instance of this for each audio clip
		 * We need to bind the spinners and progress to this, not the singleton
		 * If we had 100 in a page when would we set up bindings?
		*/
		HeadlessAudioplayer = HooWidget.extend({

			_controller:	undefined,

			_src:			undefined,	// 2 players on the page with the same audioUrl could potentially cause a problem
			ready:			undefined,
			_flashTimeout:	undefined,
			_playCount:		undefined,

			init: function( /* init never has args */ ) {

				arguments.callee.base.apply(this,arguments);
				this.ready = false;
				this.loadedSeconds = false;
				this._playCount = 0;
				var self = this;
				HeadlessAudioplayer.players.push(this);

				if( HeadlessAudioplayer.sharedHeadlessPlayer==undefined ){
					try {
						HeadlessAudioplayer.sharedHeadlessPlayer = HeadlessPlayerSingleton.create();
					} catch(err) {
			 			 $(this).trigger('booError', err);
			  			alert("NO! "+err);
			  			return;
			  		}
				}

				if( this.json.mp3Url ) {
					this._src = this.json.mp3Url;

					// incase we fail to become ready
					this._flashTimeout = setTimeout( function(){
						self.didBecomeReadyTimeOut.apply(self);
					}, 1000);

					HeadlessAudioplayer.sharedHeadlessPlayer.whenReady( this, this.didBecomeReady );
				}
			},

			// we should be observing this
			didBecomeReady: function( target, event, timeOutInstance ){

				clearTimeout( this._flashTimeout );
				this.set( "ready", YES );
			},

			didBecomeReadyTimeOut: function(){
				//alert("Flash loading timed out");
				// replace each play button with a flash instance?
			},

			play: function(){
				//TODO: Where do we check that the mp3 exits?
				HeadlessAudioplayer.sharedHeadlessPlayer.playerBecameCurrent(this);
				HeadlessAudioplayer.sharedHeadlessPlayer.play( this._src );
				this._playCount++;
			},

			// Here is a custom accessor! yay
			type: function( propKey, setterVal ) {
				if(setterVal==undefined) // getter
					return HeadlessAudioplayer.sharedHeadlessPlayer._playerBackend.type;
				else {
					// setter
				}
				return "wrong!";
			}.property()

		});
		HeadlessAudioplayer.players = new Array();	// Class variable

		/* UTILITY */

		// make this a class method! on HeadlessAudioplayer
		// woah trigger() is fucking cool man
		// we should definitely, like, use it
		function printPlayerInfos() {
			if(HeadlessAudioplayer.sharedHeadlessPlayer===undefined) {
				console.log("No players");
				return;
			}

			$.each( HeadlessAudioplayer.players, function( player_index, player_value ){
				player_value.set('type', "shit");
				console.log( "Player "+player_value+" :type "+player_value.get('type')+
					", url "+player_value._src+
					", playCount "+player_value._playCount
				);
			});
		}

- push( headless_audio_player )

-# This is a adapted from adam's player
%div[_]{ :data=>{'jsclass'=>'HeadlessAudioplayer', 'autoplay'=>'false', 'preload'=>'true'} }
	.flash_holder( style="width:50px; height:50px; background-color:#00ffff;")

	- link_to( _.mp3Url, {:style =>"position:absolute; left:-1000px;"} ) do
		play


- if( _.includeOnce? )
	:javascript

		/* Flash Callback - no longer needed */
		function BooFlashPlayerEvent( id, eventName, optionArg1 ) { /* FlashPlayerBackend.sharedInstance._flash_callBack( id, eventName, optionArg1 ) */}

		/*
		 *
		*/
		AbstractPlayerBackend = SC.Object.extend({

			_observablePlayer: undefined,
			_commandablePlayer: undefined,

			play: function(callback) {
				this._commandablePlayer.setAttribute( 'autoplay', true );
				this._commandablePlayer.play();
			},

			src: function() {
				return this._commandablePlayer.getAttribute( 'src' );
			},

			setSrc: function( url ) {
				if (!url) debugger;
				this._commandablePlayer.setAttribute( 'src', url );
				// this._commandablePlayer.type = 'audio/mpeg';
				// this._commandablePlayer.preload = "auto";
				this._commandablePlayer.load(); // force the audio to reset & start loading the new url
			},

			duration: function() {
			  	return this._commandablePlayer.getNodeProperty('duration');
			},

			// alert(video.networkState == video.NETWORK_EMPTY); // true
			buffered: function() {

			  	var timeRanges = this._commandablePlayer.getNodeProperty('buffered');
			  	if(!timeRanges){
			  		console.log("Buffered attribute NOT found");
			  		return 0;
			  	}
			  	var endTime = 0;

			  	if( timeRanges.length )
				try {
					// Discount the possibility of multiple buffers for now (theoretically possible with range requests if the user skips forward, but Safari doesn't seem to support it)
					// and just return the proportion of buffered time
					var timeRangeIndex = timeRanges.length-1;
					endTime = this._getTimeRangeEnd( timeRanges, timeRangeIndex ); // implemented differently for flash and html5
				} catch(err) {
					alert(err);
					return 0;
				}
				return endTime;
			}
		});

		/*
		 *
		*/
		FlashPlayerBackend = AbstractPlayerBackend.extend({

			_swfSrc: 		'http://0.0.0.0:3000/flash/HeadlessPlayer/lib/Debug/HeadlessPlayer.swf',
			ready:			undefined,
			_embeddedSwf:	undefined,

			init: function( /* init never has args */ ) {
				arguments.callee.base.apply(this,arguments);
				this.ready = false;
				FlashPlayerBackend.sharedInstance = this;
			},

			// Stick the swf at the end of the page
			_attachToPage: function() {

				var $wrapper = $("<div class='booPlayerHolder'/>").appendTo(document.body);
				if( !HeadlessPlayerSingleton.FlashPlayerId )
					HeadlessPlayerSingleton.FlashPlayerId = 0;
				HeadlessPlayerSingleton.FlashPlayerId++;
				var playerId = "booPlayer"+HeadlessPlayerSingleton.FlashPlayerId;

				var attemptSillyCacheFoil = YES;
				var foilString = attemptSillyCacheFoil ? "?"+encodeURIComponent(new Date().toUTCString()) : "";

				// IE doesn't like you playing with <object>s once they're created, hence the huge string blob & using innerHTML
				var objectTag = "<object data='"+this._swfSrc+foilString+"' id='"+playerId+"' type='application/x-shockwave-flash' width=50 height=50>"+
				 "<param name='movie' value='"+this._swfSrc+"'/><param name='allowScriptAccess' value='always'/><param name='FlashVars' value='rootID="+playerId+"'/></object>";
				if($.browser.msie)
					$wrapper[0].innerHTML = objectTag;
				else
					$wrapper.append(objectTag);
				this._embeddedSwf = $wrapper.find('object')[0];

				this._observablePlayer = $wrapper;
				this._commandablePlayer = this._embeddedSwf;

				// Hack in some utility functions to make sure audio element has the same interface as the swf
				this._commandablePlayer.getNodeProperty = function(propertyName){ return this[propertyName](); };

				var self = this;
				$wrapper.bind('ready', function(){ self.set('ready', YES); })
			},

			_getTimeRangeEnd: function( timeRanges, timeRangeIndex ) {
				return timeRanges[timeRangeIndex][1];
			},

			setCurrentTime: function(value) {
			// this.player._setCurrentTime(value);
			// Immediately trigger a timeupdate event because flash is quite slow to fire this on its own
			// $(this.observable).trigger('timeupdate');
			},

			pause: function(callback) {
			// if (callback)
			// return $(this.observable).bind('pause',callback);
			// if (this.playing) {
			//   this.playing = false;
			//   this.player._pause();
			// }
				return this;
			}
		});


		HTMLPlayerBackend = AbstractPlayerBackend.extend({

			ready:				undefined,
			_audioElement:		undefined,

			init: function( /* init never has args */ ) {
				arguments.callee.base.apply(this,arguments);
				this.ready = false;
			},

			// stick the audio element at the end of the page
			_attachToPage: function() {
				var audioElem = document.createElement('audio');
				var $wrapper = $("<div class='booPlayerHolder'/>").appendTo(document.body);
			  	$wrapper.append(audioElem);
				this.ready = true;				/* html5 was born ready */
			  	this._audioElement = audioElem;

				// in flash the object i observe is different than the object we command, hence this
				this._observablePlayer = this._audioElement;
				this._commandablePlayer = this._audioElement;

				// Hack in some utility functions to make sure audio element has the same interface as the swf
				this._commandablePlayer.getNodeProperty = function(propertyName){ return this[propertyName] };
			},

			_getTimeRangeEnd: function( timeRanges, timeRangeIndex ) {
				timeRanges.end(timeRangeIndex);
			}

		});


		/*
		 * we attach one swf/audio element to the page
		*/
		HeadlessPlayerSingleton = SC.Object.extend({

			_playerBackend: undefined,
			_activePlayer:	undefined,

			init: function( /* init never has args */ ) {
				arguments.callee.base.apply(this,arguments);
				this._attachWhicheverAudioPlayerToPage();
			},

			_attachWhicheverAudioPlayerToPage: function() {

				var browserHasNativeMp3Support = browserCanPlayNativeMP3();
				var browserHasFlash = hasMinimumFlash();

				var shouldUseFlashInSafari = YES;
				if(shouldUseFlashInSafari)
					isSafari = browserIsSafari();
				else
					isSafari = false;

				var useNativePlayback = browserHasNativeMp3Support && !isSafari;
				// flash may be blocked, but we still report that we have it
				if( !useNativePlayback && !browserHasFlash )
					throw("boo.oldflasherror");

				this._playerBackend = useNativePlayback ? HTMLPlayerBackend.create() : FlashPlayerBackend.create();
				this._playerBackend._attachToPage();

				/* obviously temporary - get it to work with html player first */
				this._createObservervations();
			},

			whenReady: function( target, callBack ) {

				if(this._playerBackend.ready) {
					callBack.apply(target);
				} else {
					console.log("not already ready "+ target);
					this._playerBackend.addObserver( 'ready', target, callBack );// !grr kinda leaking this
				}
			},

			_createObservervations: function(){

				// you can pass data into bind that you want your function to receive
				// $('.booPlayerHolder').bind('foo', { 'bar' : 'bam' }, function(e) { alert(e.data.bar); });

			  	// chrome
			  	// emptied, loadstart, play, waiting, error
			  	// emptied, loadstart, play, waiting, durationchange, loadedmetadat, timeupdate, loadeddata, canplay, canplaythru, timeupdate

			  	// Safari
			  	// loadstart, play, waiting, timeupdate, error
			  	// loadstart, play, waiting, durationchange, loadedmetadata, loadeddata, canplay, canplaythrough

			  	// http://www.w3schools.com/html5/html5_ref_eventattributes.asp
			  	// https://developer.mozilla.org/En/Using_audio_and_video_in_Firefox
			  	var self = this;
				var $actualPlayer = $(this._playerBackend._observablePlayer);

				$actualPlayer.bind( 'error', function( e ) {
					console.log("Event: error "+e); debugger; // Do something better on Error? Have an error state and bind the button to it?
				});

				/* Reset the loaded count */
				$actualPlayer.bind( 'loadstart', function() { self._activePlayer.set( 'loadedSeconds', 0 ); });

				/* Progress isnt always called, ie if src is a stream (or is interpreted as a stream) */
				$actualPlayer.bind( 'progress', function() {
					var loadedSecs = self._playerBackend.buffered();
					self._activePlayer.set( 'loadedSeconds', Math.floor(loadedSecs) );
				});

				$actualPlayer.bind( 'loadeddata', function() {
					var loadedSecs = self._playerBackend.buffered();
					// alert("loadedSecs "+loadedSecs);
					self._activePlayer.set( 'loadedSeconds', Math.floor(loadedSecs) );
				});

				/* Dont count on the metadata */
				// $actualPlayer.bind( 'loadedmetadata', function() {
				//	var duration = self._playerBackend._observablePlayer.duration;
				//	console.log("Event: durationchange "+duration);
				//	if( self._activePlayer.duration!=duration)
				//		self._activePlayer.set( 'duration', duration );
				//});

				$actualPlayer.bind( 'durationchange', function() {
					var durationSecs = self._playerBackend.duration();
					if( self._activePlayer.duration!=durationSecs) // Duration may have already been set on a previous play thru - preserve that value
						self._activePlayer.set( 'duration', Math.floor(durationSecs) );
				});

				$actualPlayer.bind( 'timeupdate', function() {
					var currentTimeSecs = self._playerBackend.currentTime();
					self._activePlayer.set( 'playPosition', Math.floor(currentTime) );
				});



				// can play thru is not the same as fully loaded
				// $actualPlayer.bind( 'canplaythrough', function() {
				//	console.log("Event: canplaythrough "+audioElem.duration);
				// });

				// $actualPlayer.bind( 'canplay', function() { 			console.log("Event: canplay"); });
				// $actualPlayer.bind( 'abort', function() { 				console.log("Event: abort"); });
				// $actualPlayer.bind( 'dataunavailable', function() { 	console.log("Event: dataunavailable"); });
				// $actualPlayer.bind( 'emptied', function() { 			console.log("Event: emptied"); });
				// $actualPlayer.bind( 'empty', function() { 				console.log("Event: empty"); });
				// $actualPlayer.bind( 'ended', function() { 				console.log("Event: ended"); });
				// $actualPlayer.bind( 'pause', function() { 				console.log("Event: pause"); });
				// $actualPlayer.bind( 'play', function() { 				console.log("Event: play"); });
				// $actualPlayer.bind( 'ratechange', function() { 		console.log("Event: ratechange"); });
				// $actualPlayer.bind( 'seeked', function() { 			console.log("Event: seeked"); });
				// $actualPlayer.bind( 'seeking', function() { 			console.log("Event: seeking"); });
				// $actualPlayer.bind( 'volumechange', function() { 		console.log("Event: volumechange"); });
				// $actualPlayer.bind( 'waiting', function() { 			console.log("Event: waiting"); });
			},


			reset: function() {

			},

			playerBecameCurrent: function( playerInstance ) {
				if(playerInstance!=this._activePlayer){
					this.reset();
					this.set('_activePlayer', playerInstance);
				}
			},

			play: function( mp3Url ) {
				if( mp3Url!=this._playerBackend.src )
					this._playerBackend.setSrc(mp3Url); // wait? for async callback?
				this._playerBackend.play();
			}

		});


		/*
		 * We can create an instance of this for each audio clip
		 * We need to bind the spinners and progress to this, not the singleton
		 * If we had 100 in a page when would we set up bindings?
		*/
		HeadlessAudioplayer = HooWidget.extend({

			_src:			undefined,	// 2 players on the page with the same audioUrl could potentially cause a problem
			ready:			undefined,
			loadedSeconds:	undefined,
			duration:		undefined, // duration may be NaN or Infinity
			playPosition:	undefined,
			_flashTimeout:	undefined,

			init: function( /* init never has args */ ) {

				arguments.callee.base.apply(this,arguments);
				this.ready = false;
				this.loadedSeconds = false;
				var self = this;

				if( HeadlessAudioplayer.sharedHeadlessPlayer==undefined ){
					try {
						HeadlessAudioplayer.sharedHeadlessPlayer = HeadlessPlayerSingleton.create();
					} catch(err) {
			 			 $(this).trigger('booError', err);
			  			alert("NO! "+err);
			  			return;
			  		}
				}

				if( this.json.mp3Url ) {
					this._src = this.json.mp3Url;

					this._flashTimeout = setTimeout( function(){
						self.didBecomeReadyTimeOut.apply(self);
					}, 1000);

					HeadlessAudioplayer.sharedHeadlessPlayer.whenReady( this, this.didBecomeReady );
				}
			},

			// we should be observing this
			didBecomeReady: function( target, event, timeOutInstance ){

				clearTimeout( this._flashTimeout );
				this.set( "ready", YES );
			},

			didBecomeReadyTimeOut: function(){
				//alert("Flash timed out");
				// replace each play button with a flash instance?
			},

			play: function(){
				//TODO: Where do we check that the mp3 exits?
				HeadlessAudioplayer.sharedHeadlessPlayer.playerBecameCurrent(this);
				HeadlessAudioplayer.sharedHeadlessPlayer.play( this._src );
			}
		});



		// make this a class method! on HeadlessAudioplayer
		// woah trigger() is fucking cool man
		// we should definitely, like, use it
		function printPlayerInfos() {
			$.each( HeadlessAudioplayer.players, function( index, value ){
				console.log( "Player "+value+" :type "+value.type+
					"url "+value.src+
					"playCount "+value.playCount
				);
			});
		}

		$.fn.mousedrag = function(callback) {
		  this.mousedown(function(e) {
			callback.apply(this,arguments);
			var activeElement=this;
			var mousePos = [e.pageX, e.pageY];
			$(document.body).bind('mousemove.booDrag', function(e){
			  if ((mousePos[0] == e.pageX)&&(mousePos[1]==e.pageY)) // IE fires mouse events continuously even when it doesn't move more than 1 pixel
				return;
			  mousePos = [e.pageX, e.pageY];
			  callback.apply(activeElement,arguments);
			});
			$(document.body).bind('mouseleave.booDrag mouseup.booDrag', function(){
			  $(document.body).unbind('.booDrag');
			});
			return false; //prevent text selection
		  });
		  this.bind('selectstart', function(e){return false;}); //prevent text selection in IE
		  return this;
		};

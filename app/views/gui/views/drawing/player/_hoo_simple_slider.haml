-# View should be logicless
-# No Dimensions in CSS
-# If you don't have Javascript you dont need rollovers
-# Javascript-less site should be minimal and semantic

-# http://0.0.0.0:3000/widgets/HooSimpleSlider?initialState=1

-# push( hoo_simple_slider )

-# adding the data-jsclass attribute means that a javascript instance will be created on-load
-# Todo: I also need to have it created if it is inserted by ajax!
%div[_]( data-jsclass='ABoo.HooSimpleSlider' style="position:relative; height: 15px; background:transparent url(../images/player/timeline_background.png) no-repeat left top;" )

	%div.slider
		.slidingDoor_left( style="display:block; height: 15px; overflow: hidden;" )
			.slidingDoor_right( style="display:inline-block; float: right; background:transparent url(../images/player/timeline_background.png) no-repeat right bottom; green; width: 15px; height: 15px; overflow: hidden;" )


		%div.loadProgress( style="width:180px; height: 11px; background-color:#ededed; position: absolute; top: 0; margin: 2px; opacity:0.5;" )
		%div.playProgress( style="width:180px; height: 11px; background-color:#ff005b; position: absolute; top: 0; margin: 2px;" )

		-# %canvas( width="100" height="12" style="position:absolute; top:0; margin:2px;" )

	-#.nubbin( style="width:20px; height:20px; background-color:#00ff00;" )

	=  insert( _.views, "" )

- if( _.includeOnce? )
	:javascript




		/*
		 * yes this looks less thaN USEFUL to me too
		*/
		ABoo.HooSimpleSliderGraphic = ABoo.HooButtonGraphic.extend({

			showDisabledButton: function() {
				//alert("one");
		    },
			showMouseUp1State: function() {
				//alert("two");
			},
			showMouseDown1State: function() {
				//alert("threes");
			}
		});

		/*
		 *
		*/
		ABoo.HooSimpleSlider = ABoo.HooFormButtonSimple.extend({

			_loadProgressDiv:	undefined,
			_playProgressDiv:	undefined,
			_started:			false,
			_timeStep:			undefined,
			_currentTime:		undefined,
			_loadedAmount:		0,
			_playedAmount:		0,
			_maxAmount:			0,
			_maxBarWidth:		0,
			_currentWidth:		0,
			_currentWHeight:	0,

			//mwah _busyFadeHelper:	undefined,
			//mwah _stateMachine: 		undefined,
			//mwah _hooCanvas: undefined,

			init: function( /* init never has args */ ) {
				this._super();
				this._loadProgressDiv = this.getFirstDomItemOfType(".loadProgress");
				this._playProgressDiv = this.getFirstDomItemOfType(".playProgress");

				//mwah this._loadedAmount = 0;
				//mwah this._playedAmount = 0;
				//mwah this._timeStep = 1000/15;
				//mwah this._currentTime = 0;

				//mwah this._stateMachine = ABoo.HooSliderItem.create();
				//mwah this._stateMachine._delegate = this;
				//mwah this._stateMachine._setupStateMachine( 0 );
				//mwah this._stateMachine.setInitialState( 0 );

				//mwah this._busyFadeHelper = ABoo.BusyFadeHelper.create();
			},

			_createGraphic: function() {
				return ABoo.HooSimpleSliderGraphic.create( { _rootItemId:this.id, _itemType:".slider" } ); // _textHolder:"span", _labelStates: this.json.labelStates
			},

			_createStateController: function() {
				return ABoo.HooSliderItem.create( { _graphic:this._buttonGraphic } );
			},

			setupDidComplete: function() {

				this._super();
				//mwah HOO_nameSpace.assert( this._hooCanvas, "this button must be added to a canvas to work" );

				// some disaster of order of operations here - resizeAll has alreadyw been called too many times, we just werent ready
				this._started = true;
				this.resizeAll();

				//mwah /* Redo Bindings */
				//mwah var hasBinding = this.setup_hoo_binding_from_json( 'enabledBinding' );
				//mwah if( hasBinding==false && this.json.initialState>0 ) {
				//mwah 	this._stateMachine.processInputSignal( "enable" );
				//mwah }

				var hasMaxValBinding = this.setup_hoo_binding_from_json( 'maxAmountValueBinding' );
				var hasLoadedValBinding = this.setup_hoo_binding_from_json( 'loadedValueBinding' );
				var hasPlayedValBinding = this.setup_hoo_binding_from_json( 'playedValueBinding' );

				// remember! the alert stuff doesnt work in ie
				//mwah this._mouseClickAction = this.setup_hoo_action_from_json( 'mouseClickAction' );
			},


			// we observed a change!
			// If no binding is found this gets called anyway? So assume default is on?
			readyDidChange: function( target, property ) {

				//pbtarget.removeObserver( property, this, this.readyDidChange );
				// handle disable as well as enable?

				// why does this seem to be
				if( target.get(property) ) {
					this._buttonSMControl.sendEvent( "ev_showState1" );
				}
			},

			/* we observed a change! - notification callback */
			maxAmountDidChange:  function( target, property ) {
				var updatedVal =  target[property];
				this.set( '_maxAmount', updatedVal );
				this.recalcLoadedAndPlayedAmounts();
			},


			/* we observed a change! - notification callback */
			loadedDidChange: function( target, property ) {
				var percent = ABoo.HooMath.xAsUnitPercentOfY( target[property], this._maxAmount );
				this.setLoadAmount(percent);
			},

			/* we observed a change! - notification callback */
			playedDidChange: function( target, property ) {
				var updatedAmount = target[property];
				var percent = ABoo.HooMath.xAsUnitPercentOfY( updatedAmount, this._maxAmount );
				//console.log("Played "+updatedAmount+" "+percent );
				this.setPlayAmount(percent);
			},


			recalcLoadedAndPlayedAmounts: function() {
				this.setPlayAmount(this._playedAmount);
				this.setLoadAmount(this._loadedAmount);
			},

			// could/should do this with SC bindings?
			setPlayAmount: function( arg ) {
				this.set( '_playedAmount', arg );
				var playDivWidth = this._maxBarWidth*this._playedAmount;
			    this._playProgressDiv.width( playDivWidth );
			},

			setLoadAmount: function( arg ) {
				this.set( '_loadedAmount', arg );
				var loadDivWidth = this._maxBarWidth*this._loadedAmount;
				// console.log("LoadDivWidth = "+this._maxBarWidth);
			    this._loadProgressDiv.width(loadDivWidth);
			},

			//mwah  getClickableItem: function() {
			//mwah 	alert("oh really?");
			//mwah 	return  this.getFirstDomItemOfType(".slider");
			//mwah },

			parentDidResize: function() {

				//if(Modernizr.canvas!==undefined)
				if(this._started===true)
					this.resizeAll();
				//}
			},

			resizeAll: function() {

				var newWidth = this.div$.width();
				var newHeight = this.div$.outerHeight();
				//var currentWidth = this._$canvas.width();
				//var currentHeight = this._$canvas.outerHeight();

				console.log("resize "+newWidth);

				if( newWidth!=this._currentWidth || newHeight!=this._currentHeight ) {


					// resize canvas
					//mwah this._$canvas.attr({ width:newWidth, height:newHeight }); // setting the size resets the canvas
					//mwah var ctx = this._$canvas[0].getContext('2d');

					this._maxBarWidth = newWidth-4;
					var maxBarHeight = newHeight-4;

				    //mwah this.draw(ctx, this._maxBarWidth, maxBarHeight);

					this.recalcLoadedAndPlayedAmounts();

					this._currentWidth = newWidth;
					this._currentHeight = newHeight;
				}
			},


			toggleBusy: function() {
				//mwah if(this._busyFadeHelper._showBusy)
				//mwah 	this.stopBusy();
				//mwah else
				//mwah	this.startBusy();
			},

			startBusy: function() {

				var self = this;
				//mwah this._busyFadeHelper._animFunction = function() {
					//mwah var ctx = self._$canvas[0].getContext('2d');
				    //mwah self.draw(ctx, self.div$.width(), self.div$.outerHeight());
					//mwah self._currentTime = (self._currentTime + self._timeStep) % 1000;
				//mwah }
				//mwah this._busyFadeHelper.begin( self._timeStep );
			},

			stopBusy: function() {
				//mwah this._busyFadeHelper.end();
			},


			// wtf is this?
			//temporarySetEnabledState: function( stateIndex, enabled ) {
			//	alert("wtf");
			//},
			//enableButton: function( stateIndex ) {
			//	alert("wtf");
			//},
			//showMouseUpState: function( stateIndex ) {
			//	alert("wtf");
			//	alert("woo mouse up");
			//},
			//showMouseDownState: function( stateIndex ) {
			//	alert("wtf");
			//	if(this._mouseClickAction) {
			//		var newPos = this.localXPosition();
			//		this._lastDragXAmount = newPos;
			//		console.log("click at pos "+newPos);
			//		this._mouseClickAction.a.call( this._mouseClickAction.t, newPos );
			//	}
			//},
			//mouseDragged: function(e){
			//	alert("wtf");
			//	if(this._mouseClickAction) {
			//		var xamount = this.localXPosition();  // IE fires mouse events continuously even when it doesn't move more than 1 pixel
			//		if( xamount!=this._lastDragXAmount) {
			//			this._mouseClickAction.a.call( this._mouseClickAction.t, xamount );
			//			this._lastDragXAmount = xamount;
			//		}
			//	}
			//},

			//fireAction: function( nextState, argsHash ) {
			//	alert("wtf");

			//	argsHash.onCompleteAction.call( argsHash.onCompleteTarget );
			//},

			// convert mouse coord to slider position
			//localXPosition: function(){
			//	alert("wtf");

			//	if(this._stateMachine.lastWindowEvent) {
			//		var x = this._stateMachine.lastWindowEvent.pageX;
			//		var y = this._stateMachine.lastWindowEvent.pageY;
			//		var pos = this._loadProgressDiv.offset();
			//		var xval;
			//		// var size = [this._loadProgressDiv.width(), this._loadProgressDiv.height()];
			//		if( pos.left>x )
			//			xval = 0;
			//		else if((pos.left + this._maxBarWidth)<x)
			//			xval = 1;
			//		else
			//			xval = (x-pos.left)/this._maxBarWidth;
			//		if(xval > this._loadedAmount)
			//			xval  = this._loadedAmount
			//		return xval;
			//	}
			//	return -1;
			//}

		});

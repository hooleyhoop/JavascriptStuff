- push( hoo_speech_bubble_bottom_canvas )

-# http://0.0.0.0:3000/widgets/speechBubbleBottomCanvas
-# Speech Bubble is actual a split view with a panel on the left and the speech thingy on the right

-# Top Elastic Row
%div[_]{ :class=>"speechBubble", :data=>{'jsclass'=>'HooSpeechBubbleBottomCanvas'}, :style =>"margin:auto; overflow:visible; width:100%" }
	%canvas( width="100%" height="100%" style="border:0 solid white; z-index: -1; position: absolute; ")

	%div( class="panel_style_inner" style="position: relative;" )

		%div.speechBubble_top_middle{ :style=>"position: absolute; overflow: auto; background: url( #{_.top} ) repeat-x left top; height: #{_.cornerDim}px; left:#{_.cornerDim}px; right: #{_.cornerDim}px; " }
		%div.speechBubble_top_left{ :style=>"width: #{_.cornerDim}px; height: #{_.cornerDim}px; float:left; background: url( #{_.corners} ) left top no-repeat;" }
		%div.speechBubble_top_right{ :style=>"width: #{_.cornerDim}px; height: #{_.cornerDim}px; float:right; background: url( #{_.corners} ) right top no-repeat;" }

		%div.speechBubble_top{ :style=>"padding-top: #{_.cornerDim}px;" }

			%div.speechBubble_bottom{ :style=>"padding-bottom: #{_.cornerDim}px;" }

				%div.speechBubble_left_middle{ :style=>"position: absolute; height:auto; background: url( #{_.left} ) repeat-y left top; width: #{_.cornerDim}px; top:#{_.cornerDim}px; bottom: #{_.cornerDim}px; overflow: auto;" }

				%div.speechBubble_left{ :style=>"padding-left: #{_.cornerDim}px;" }

					%div.speechBubble_right{ :style=>"padding-right: #{_.cornerDim}px; background: url( #{_.right} ) repeat-y right top;" }

						%div.speechBubble_inner{ :style=>"background: url( #{_.fill} ) repeat left top; background-origin: border-box; padding:0 0 0 0;" }
							=  insert( _.views, "" )
							%div( style="clear:both;")

				%div.speechBubble_bottom_left{ :style=>"width: #{_.cornerDim}px; height: #{_.cornerDim}px; float:left; background: url( #{_.corners} ) left bottom no-repeat;" }
				%div.speechBubble_bottom_right{ :style=>"width: #{_.cornerDim}px; height: #{_.cornerDim}px; float:right; background: url( #{_.corners} ) right bottom no-repeat;" }
				%div.speechBubble_bottom_middle{ :style=>"position: absolute; width: auto; background: url( #{_.bottom} ) repeat-x left bottom; height: #{_.cornerDim}px; left:#{_.cornerDim}px; right: #{_.cornerDim}px; " }



	-# Bottom Fixed Row
	%div.triangle{ :style=>"height: #{_.fixedRowHeight}px; position:relative; top:-1px; left:30px;" }
		-# Draw a div with a background img at fixed size
		- img_attrs = { :style=>"width:#{_.triangleImgSize[0]}px; height:#{_.triangleImgSize[1]}px; background: url( #{_.triangleImgpath} ) left top no-repeat;" }
		%div{img_attrs}



-# Obviously we cannot leave this here as it is crazy to include it more than once
- if( _.includeOnce? )

	%style(type="text/css")
		:sass

			// Lovely modernizr stuff. if .borderradius and rgba are supported rip out the background images and use css rounded corners instead
			// body
			//	background: none!important
			//	background-color: red!important

			// remove each background image
			// Bah! If you disable javascript, you dont get moderninzer
			.canvas.rgba .speechBubble
				.speechBubble_top_middle, .speechBubble_top_left, .speechBubble_top_right, .speechBubble_left_middle, .speechBubble_right, .speechBubble_inner, .speechBubble_bottom_left, .speechBubble_bottom_right, .speechBubble_bottom_middle
					background: none no-repeat !important
				.triangle div
					background: none no-repeat !important



	:javascript

		HooSpeechBubbleBottomCanvas = HooWidget.extend({

			_$parentDiv: undefined,
			_$canvas: undefined,

			init: function( /* init never has args */ ) {
				arguments.callee.base.apply(this,arguments);

				this._$parentDiv = $( "#"+this.id );
				this._$canvas = this._$parentDiv.find( "canvas:first" );
				this.resizeCanvas();
			},

			parentDidResize: function() {
				this.resizeCanvas();
			},

			resizeCanvas: function() {
				var newWidth = this._$parentDiv.width();
				var newHeight = this._$parentDiv.height();
				var currentWidth = this._$canvas.width();
				var currentHeight = this._$canvas.height();
				if( newWidth!=currentWidth || newHeight!=currentHeight)
				{
					this._$canvas.attr({ width:newWidth, height:newHeight }); // setting the size resets the canvas
					var ctx = this._$canvas[0].getContext('2d');
				    this.draw(ctx, newWidth, newHeight);
				}
			},

			draw: function( ctx, width, height ) {

				if( height%15!=0) console.error("why is this height fucked? "+height);
				console.log("height is "+height);
				var gradient;

				var anticlockwise = true;
				var south = Math.PI/2;
				var east = 0;
				var west = Math.PI;
				var north = Math.PI*3/2;

				var cornerRad = 12;	// make this dynamic?
				var nubbinWidth = 30;
				var nubbinHeight = 12;

				// layer1/Path
				ctx.save();
				ctx.save();

				ctx.shadowColor = "rgba(0, 0, 0, 0.2)";
				ctx.shadowOffsetX = 1;
				ctx.shadowOffsetY = 3.0;
				ctx.shadowBlur = 3.0;

				ctx.beginPath();

				var startx = 1;
				var starty = 1;
				width = width-2;
				height = height-2 - 3; // allow for shadow

				// antio- clockwise origin top left
				var penx = startx;
				var peny = starty+cornerRad;
				ctx.moveTo( penx, peny );
				peny += height-cornerRad-cornerRad-nubbinHeight;
				ctx.lineTo( penx, peny );

				// bottom left corner
				ctx.arc( penx+cornerRad, peny, cornerRad, west, south, anticlockwise );

				// to nubbin
				penx += nubbinWidth;
				peny += cornerRad;
				ctx.lineTo(penx, peny);

				// nubbin pt
				penx += nubbinWidth/2;
				peny += nubbinHeight;
				ctx.lineTo(penx, peny);

				penx += nubbinWidth/2;
				peny -= nubbinHeight;
				ctx.lineTo(penx, peny);

				penx += width-cornerRad-nubbinWidth-nubbinWidth;
				peny += 0;
				ctx.lineTo(penx, peny);

				// bottom right corner
				peny -= cornerRad;
				ctx.arc( penx, peny, cornerRad, south, east, anticlockwise );

				penx += cornerRad;
				peny -= height-cornerRad-cornerRad-nubbinHeight;
				ctx.lineTo( penx, peny );

				// top right
				penx -= cornerRad;
				ctx.arc( penx, peny, cornerRad, east, north, anticlockwise );

				penx -= width-cornerRad-cornerRad;
				peny -= cornerRad;
				ctx.lineTo( penx, peny );

				// top left
				peny += cornerRad;
				ctx.arc( penx, peny, cornerRad, north, west, anticlockwise );

				ctx.closePath();

				gradient = ctx.createLinearGradient(122.5, 1.1, 122.5, 201.3);
				gradient.addColorStop(0.00, "rgba(255, 255, 255, 1)");
				gradient.addColorStop(0.3, "rgba(255, 255, 255, 1)");
				gradient.addColorStop(1.0, "rgba(125, 125, 200, 1)");

				ctx.fillStyle = "rgba(255, 255, 255, 0.9)";
				ctx.fill();

				ctx.fillStyle = gradient;
				ctx.fill();

				//ctx.stroke();
				ctx.restore();
				ctx.restore();

			}
		});


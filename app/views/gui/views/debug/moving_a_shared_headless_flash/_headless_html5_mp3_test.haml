-# http://0.0.0.0:3000/widgets/HeadlessHtml5Mp3Test
-# http://shooley.audioboo.fm:3000/widgets/HeadlessHtml5Mp3Test

- push( headless_html5_mp3_test)

- wrapLiveObject( _, :style=>'border:1px solid black; margin:3px; background-color: white;' ) do
	-# TODO: really we want a link here, right? Then in js we remove the link and show the image,
	-# or we could put the image in as well as the link. Ok, so the link is optional
	= image_tag("rails.png", :style=>"padding-right: 10px; padding-top: 5px;" )
	= link_to "click to play mp3", _.mp3Url

- if( _.includeOnce? )
	:javascript

		/*
		 * Only one of these per page
		*/
		ABoo.NewHeadlessHTML5PlayerSingleton = SC.Object.extend({
			_headlessAudioOb: undefined,

			// create the backing html5
			init: function( /* init never has args */ ) {
				this._super();
				 this._headlessAudioOb = ABoo.HeadlessSharedDivObject.sharedDivForTag( "audio" );
			},

			playerBecameCurrent: function( playerInstance, $pageItem ) {
				// NB, it only physically swaps in when fails to load due to flash blocker
				this._headlessAudioOb.swapInForItem( playerInstance, $pageItem );
			},

			setSrc: function( mp3Url2 ) {
				if (!mp3Url2) debugger;

				// TODO: check duplicate url ? as in beeper
				console.log("SRC: "+mp3Url2);

				this._headlessAudioOb._commandableSwf.setAttribute( 'src', mp3Url2 );

				// this._commandableSwf.type = 'audio/mpeg';
				// this._commandableSwf.preload = "auto";

				/* seems like player doesn't need to be appended? */
				this._headlessAudioOb._commandableSwf.setAttribute( 'autoplay', true );
				this._headlessAudioOb._commandableSwf.load();
			},

			_getTimeRangeEnd: function( timeRanges, timeRangeIndex ) {
				return timeRanges.end(timeRangeIndex);
			},

			buffered: function() {

			  	var timeRanges = this._headlessAudioOb._commandableSwf.getNodeProperty('buffered');
			  	if(!timeRanges){
			  		console.log("Buffered attribute NOT found");
			  		return 0;
			  	}
			  	var endTime = 0;

			  	if( timeRanges.length )
				try {
					// Discount the possibility of multiple buffers for now (theoretically possible with range requests if the user skips forward, but Safari doesn't seem to support it)
					// and just return the proportion of buffered time
					var timeRangeIndex = timeRanges.length-1;
					endTime = this._getTimeRangeEnd( timeRanges, timeRangeIndex ); // implemented differently for flash and html5
				} catch(err) {
					alert(err);
					return 0;
				}
				return endTime;
			},

			duration: function() {
				var dur = this._headlessAudioOb._commandableSwf.getNodeProperty('duration');
				dur = (isNaN(dur)) ? 0 : dur;
				//console.log("DUR: "+dur);
			  	return dur;
			},

			loadedDegrees: function() {
				var buffered = this.buffered();
				var duration =  this.duration();
				var degrees = duration===0 ? 0 : (buffered / duration * 360);
				console.log("<<<<< loadedDegrees "+buffered+" "+duration+" >>>>>> "+degrees );
				return degrees
			},

			playedDegrees: function() {
				var ct = this._headlessAudioOb._commandableSwf.getNodeProperty('currentTime');
				var duration =  this.duration();
				return duration===0 ? 0 : (ct / duration * 360);
			},

			// TODO: when you play we have to manually update playcount (first time thru only)
			play: function() {
				this._headlessAudioOb._commandableSwf.play();
			},

			pause: function() {
				this._headlessAudioOb._commandableSwf.pause();
			}

		});

		ABoo.NewHeadlessHTML5PlayerSingletonClassMethods = SC.Mixin.create({

			_sharedHeadlessPlayer: undefined,

			sharedHeadlessPlayer: function() {
				if( this._sharedHeadlessPlayer==undefined ){
					this._sharedHeadlessPlayer = ABoo.NewHeadlessHTML5PlayerSingleton.create();
				}
				return this._sharedHeadlessPlayer;
			}
		});
		SC.mixin( ABoo.NewHeadlessHTML5PlayerSingleton, ABoo.NewHeadlessHTML5PlayerSingletonClassMethods );


		/*
		 * One of these for each instance on the page
		*/
		ABoo.NewHeadlessHtml5PlayerBackend = SC.Object.extend({

			_mp3URL: undefined,
			_controller: undefined,
			_watchableEvents: 'error emptied loadstart progress loadeddata loadedmetadata durationchange timeupdate canplay canplaythrough waiting play ended abort dataunavailable empty pause ratechange seeked seeking volumechange stalled',

			// TODO: remove this in favor of state machine
			_state: false,

			_stateMachine: undefined,

			_attachToPage: function( $pageItem ) {

				this._stateMachine = ABoo.AudioPlayerStateMachine.create( {_controller: this._controller } );

				ABoo.NewHeadlessHTML5PlayerSingleton.sharedHeadlessPlayer().playerBecameCurrent( this, $pageItem );
			},

			// this doesn't mean that the swf is ready
			didSwapInFlash: function( swf ) {
				this._state = true;
				console.log("SWApped in");
			},

			didSwapOutFlash: function( swf ) {
				console.log("swapped out");
				this._state = false;
				this._killObservations();
				this._controller.hidePlayerGUI();
				//ABoo.NewHeadlessHTML5PlayerSingleton.sharedHeadlessPlayer().setSrc( "" );
			},

			flashDidLoad: function( swf ) {
				this._controller.showPlayerGUI();

				this._createObservervations();
				this._stateMachine.processInputSignal( "ready" );

				ABoo.NewHeadlessHTML5PlayerSingleton.sharedHeadlessPlayer().setSrc( this._mp3URL );

				// TODO: hold off on this for now.
				// ABoo.NewHeadlessHTML5PlayerSingleton.sharedHeadlessPlayer().play( this._mp3URL );
			},

			//TODO: must we tear down observations also
			_createObservervations: function(){
			  	var self = this;
				var $actualPlayer = $( ABoo.NewHeadlessHTML5PlayerSingleton.sharedHeadlessPlayer()._headlessAudioOb._observableSwf );
				$actualPlayer.bind( this._watchableEvents, function( e ) {
					self.handleHeadlessFlashPlayerEvent(e.type);
				});
			},

			_killObservations: function() {
				var $actualPlayer = $( ABoo.NewHeadlessHTML5PlayerSingleton.sharedHeadlessPlayer()._headlessAudioOb._observableSwf );
				$actualPlayer.unbind( this._watchableEvents );
			},

			handleHeadlessFlashPlayerEvent: function( eventName ) {

				if(eventName!="timeupdate")
					console.log("HTML5 player: got an event > " + eventName );

				// TODO: shit shit and bugger!
				if(eventName!="loadeddata")
					this._stateMachine.processInputSignal( eventName );
			},

			buffered: function() {
				return ABoo.NewHeadlessHTML5PlayerSingleton.sharedHeadlessPlayer().buffered();
			},

			loadedDegrees: function() {
				return ABoo.NewHeadlessHTML5PlayerSingleton.sharedHeadlessPlayer().loadedDegrees();
			},

			playedDegrees: function() {
				return ABoo.NewHeadlessHTML5PlayerSingleton.sharedHeadlessPlayer().playedDegrees();
			},

			play: function() {
				return ABoo.NewHeadlessHTML5PlayerSingleton.sharedHeadlessPlayer().play();
			},

			pause: function() {
				return ABoo.NewHeadlessHTML5PlayerSingleton.sharedHeadlessPlayer().pause();
			}
		});


		/*
		 * Small Player with canvas front-end (html5 backend)
		*/
		#{_.qualifiedJsClassName} = ABoo.SCView.extend({

			_html5PlayerBackend: undefined,
			_canvas$: undefined,
			_hooCanvas: undefined,
			_placeHolder$: undefined,
			_smallPlayerFrontEnd: undefined,

			/* properties to bind to. neccesary? */
			_ready: false,
			_loadProgress: 0,
			_playProgress: 0,
			_busyFlag: false,

			didInsertElement: function() {
				this._super();

				var noJsAnchor$ = this.getFirstDomItemOfType("a");
				noJsAnchor$.remove();

				this._placeHolder$ = this.getFirstDomItemOfType("img");
				this._html5PlayerBackend = ABoo.NewHeadlessHtml5PlayerBackend.create( {_controller:this, _mp3URL:this.json.mp3Url} );
			},

			mouseUp: function(ev$) {

				// TODO: this is the pits..
				if( this._html5PlayerBackend._state == false ) {
					if( this._placeHolder$ ) {
						this._html5PlayerBackend._attachToPage( this._placeHolder$ );
					}
				}
			},


			// can we draw the playbutton?
			showPlayerGUI: function() {

				SC.RunLoop.begin();

				// TODO: move into a constructor on canvas?
				this._canvas$ = $("<canvas>"); //TODO: does the canvas need to be in a wrapper to stretch it to 100%?

				// remove the image and insert the canvas
				this._placeHolder$.replaceWith( this._canvas$ );

				this._hooCanvas = ABoo.HooCanvas.create( { _$canvas: this._canvas$ } );

				// TODO: not how we will size it, but just to make it visible for now
				this._hooCanvas._setSize(200,200);

				// At last! we have found the bit where the whole scheme fails!
				var thePlayButtonJson = { "percentOfCanvas":0.7,
											"javascriptActions":{"mouseClickAction":{"action_taget":this, "action_event":["playClickAction", "pauseClickAction"], "action_arg":null, "actionIsAsync":true}}
										};
				var theRadialProgressJson = { "outerRad":0.95, "innerRad":0.85 };


				var radialProgress = ABoo.HooRadialProgress.create( {json:theRadialProgressJson, _hooCanvas: this._hooCanvas } );
				var playPause = ABoo.HooPlayPauseButton.create( {json:thePlayButtonJson, _hooCanvas: this._hooCanvas } );
				console.warn("created radial "+radialProgress+" and play "+playPause);
				this._smallPlayerFrontEnd = ABoo.SmallPlayerPlayButton.create( {_radialProgress:radialProgress , _playPauseButton:playPause });

				// TODO: dont forget to clean these up
				this.addObserver('_loadProgress', radialProgress, radialProgress.loadDidChange );
				this.addObserver('_playProgress', radialProgress, radialProgress.playDidChange );
				this.addObserver('_busyFlag', radialProgress, radialProgress.busyDidChange );
				this.addObserver('_ready', playPause, 'enabledDidChange' )

				radialProgress.setupDidComplete();
				playPause.setupDidComplete();
				this._smallPlayerFrontEnd.setupDidComplete();

				SC.RunLoop.end();
			},

			hidePlayerGUI: function() {
				if(this._canvas$) {
					$(this).stop();

					var radialProgress = this._smallPlayerFrontEnd._radialProgress;
					var playPause = this._smallPlayerFrontEnd._playPauseButton;

					this.removeObserver('_loadProgress', radialProgress, radialProgress.loadDidChange );
					this.removeObserver('_playProgress', radialProgress, radialProgress.playDidChange );
					this.removeObserver('_busyFlag', radialProgress, radialProgress.busyDidChange );
					this.removeObserver('_ready', playPause, 'enabledDidChange' )

					// TODO: not sure we will create and destroy the canvas each time
					this._hooCanvas.removeAllSubviews();

					//TODO: put back the image
					this._canvas$.replaceWith( this._placeHolder$ );
					this._canvas$ = null;
				}
			},

			/* state machine events */
			ready: function() {
				//not needed? this.set('_ready', true );
				//_guiSprite.setPlayButtonActions(/* fill in args */);

				// it shows ready too soon!!!!
			},
			durationchange: function() {
				console.log("durationchange" );

				// so, load progress events are sketchy to say the least, attach loadProgress checks everywhere we can..
				this._fakeLoadProgressEvent();
			},

			// seems like we dont always get progress events.. manually check
			_fakeLoadProgressEvent: function() {
				var loadedDegrees = this._loadProgress;
				var reportedLoadedDegress = this._html5PlayerBackend.loadedDegrees();
				if( loadedDegrees!=reportedLoadedDegress )
					this.animateLoadProgress( loadedDegrees, reportedLoadedDegress );
			},

			// TODO: boiler plate - move
			animateLoadProgress: function( from, to ) {
				//console.warn("Animate from "+from+" to "+to);
				//if(from==0 && to==360)
				//	debugger;
				//var fromProgressVal = { progress: from };
				this.fakeLoadProgress = from;	// we need the fake because i dont think we can stop $animate directly setting some value, and we need to make sure the setter is called for the real property that we want to set
				var toLoadProgressVal = { fakeLoadProgress: to };
				var self = this;
				jQuery(this).animate( toLoadProgressVal, {
					duration: 1000,
					step: function(now, fx) {
						//console.log("Anim: "+fx.elem.id + ' ' + fx.prop + ': ' + now);
						self.set('_loadProgress', now );
					},
					queue: false
				});
			},

			// TODO: boiler plate - move
			animatePlayProgress: function( from, to ) {
				//var fromProgressVal = { progress: from };
				this.fakePlayProgress = from;	// we need the fake because i dont think we can stop $animate directly setting some value, and we need to make sure the setter is called for the real property that we want to set
				var toPlayProgressVal = { fakePlayProgress: to };
				var self = this;
				jQuery(this).animate( toPlayProgressVal, {
					duration: 1000,
					step: function(now, fx) {
						//console.log("Anim: "+fx.elem.id + ' ' + fx.prop + ': ' + now);
						//console.warn(now);
						self.set('_playProgress', now );
					},
					queue: false
				});
			},

			// Beacuse the button action is specified as 'async' it will not automatically show the next state
			// when clicked, we change it when audio player statemachine tells us too
			_showPlay: function() {
				this._smallPlayerFrontEnd._playPauseButton._buttonSMControl.sendEvent( "ev_showState1" );
			},

			_showPause: function() {
				this._smallPlayerFrontEnd._playPauseButton._buttonSMControl.sendEvent( "ev_showState2" );
			},

			_showDisabled: function() {
				this._smallPlayerFrontEnd._playPauseButton._buttonSMControl.sendEvent( "ev_showState1" );
			},

			progressupdate: function() {
				var loadedDegrees = this._loadProgress;
				if( loadedDegrees>0 )
					this.set('_busyFlag', false);
				this.animateLoadProgress( loadedDegrees, this._html5PlayerBackend.loadedDegrees() );
			},

			timeupdate: function() {
				this.animatePlayProgress( this._playProgress, this._html5PlayerBackend.playedDegrees() );

				// TODO: This is horrible
				//this._fakeLoadProgressEvent();
			},

			/* loading commands */
			cmd_showEmptyLoader: function() {
				jQuery(this).stop();
				this.set('_loadProgress', 0);
				this.set('_playProgress', 0);
				this.set('_busyFlag', false);
			},
			cmd_showStalledLoader: function() {
				this.set('_busyFlag', true);
			},
			cmd_showLoadingLoader: function() {
			},
			//cmd_showFinishedLoader: function() {
			//	this.animateLoadProgress( this._loadProgress, 360 );
			//	this.set('_busyFlag', false);
			//},
			//cmd_showResettingLoader: function() {
			//},
			cmd_showErrorLoader: function() {
				this._showDisabled();
				this.set('_busyFlag', true);
			},

			/* playing commands */
			cmd_showEmptyPlayer: function() {
				this._showDisabled();
			},
			cmd_showStoppedPlayer: function() {
				this._showPlay();
			},
			cmd_showWaitingPlayer: function() {
				this.set('_busyFlag', true);
			},
			cmd_hideWaitingPlayer: function() {
				this.set('_busyFlag', false);
			},
			cmd_showPlayingPlayer: function() {
				this._showPause();
			},
			cmd_showFinishedPlayer: function() {
				jQuery(this).stop();
				this.set( '_playProgress', 0 );
				this._showPlay();
			},
			cmd_showErrorPlayer: function() {
				this._showDisabled();
			},

			/* Button Actions */
			playClickAction: function() {
				this._html5PlayerBackend.play();
			},
			pauseClickAction: function() {
				this._html5PlayerBackend.pause();
			}

		});



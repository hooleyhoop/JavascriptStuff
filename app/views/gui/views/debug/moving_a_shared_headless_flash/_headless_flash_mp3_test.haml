-# http://0.0.0.0:3000/widgets/HeadlessFlashMp3Test
-# http://shooley.audioboo.fm:3000/widgets/HeadlessFlashMp3Test

-# push( headless_flash_mp3_test)

- wrapLiveObject( _, :style=>'border:1px solid black; margin:3px; background-color: white;' ) do
	-# TODO: really we want a link here, right? Then in js we remove the link and show the image,
	-# or we could put the image in as well as the link. Ok, so the link is optional
	= image_tag("rails.png", :style=>"padding-right: 10px; padding-top: 5px;" )
	= link_to "click to play mp3", _.mp3Url

- if( _.includeOnce? )
	:javascript

		/*
		 * Only one of these per page
		*/
		ABoo.NewHeadlessFlashPlayerSingleton = ABoo.NewHeadlessPlayerSingleton.extend({
			_swfSrc: "HeadlessPlayer/lib/Debug/HeadlessPlayer",
			_headlessFlashOb: undefined,

			// create the backing swf
			init: function( /* init never has args */ ) {
				this._super();
				var flashURL = ABoo.HeadlessSharedFlashObject.uRLForSwf( this._swfSrc );

				// varoius autostart options here - load, play, etc. - cant really use 'em to stay consistent with html5 audio
				this._headlessFlashOb = ABoo.HeadlessSharedFlashObject.sharedSwfForURL( flashURL, '100%', '100%', {autostart:'load'} );
				this._audioPlayingDomNode = this._headlessFlashOb;
			},

			_getTimeRangeEnd: function( timeRanges, timeRangeIndex ) {
				return timeRanges[timeRangeIndex][1];
			}

		});

		ABoo.NewHeadlessFlashPlayerSingletonClassMethods = SC.Mixin.create( ABoo.SingletonClassMethods, {
		});
		SC.mixin( ABoo.NewHeadlessFlashPlayerSingleton, ABoo.NewHeadlessFlashPlayerSingletonClassMethods );


		/*
		 * One of these for each instance on the page
		*/
		ABoo.NewHeadlessFlashPlayerBackend = SC.Object.extend({

			_mp3URL: undefined,
			_controller: undefined,
			_watchableEvents: 'error emptied loadstart progress loadeddata loadedmetadata durationchange timeupdate canplay canplaythrough waiting play ended abort dataunavailable empty pause ratechange seeked seeking volumechange stalled',

			// TODO: remove this in favor of state machine
			_state: false,

			_stateMachine: undefined,

			_attachToPage: function( $pageItem ) {

				this._stateMachine = ABoo.AudioPlayerStateMachine.create( {_controller: this._controller } );

				ABoo.NewHeadlessFlashPlayerSingleton.sharedInstance().playerBecameCurrent( this, $pageItem );
			},

			// this doesn't mean that the swf is ready
			didSwapInFlash: function( swf ) {
				this._state = true;
			},

			didSwapOutFlash: function( swf ) {
				this._state = false;
				this._killObservations();
				this._controller.hidePlayerGUI();
			},

			flashDidLoad: function( swf ) {
				this._controller.showPlayerGUI();

				this._createObservervations();
				this._stateMachine.processInputSignal( "ready" );

				ABoo.NewHeadlessFlashPlayerSingleton.sharedInstance().setSrc( this._mp3URL, true, true );

				// TODO: hold off on this for now.
				// ABoo.NewHeadlessFlashPlayerSingleton.sharedInstance().play( this._mp3URL );
			},

			//TODO: must we tear down observations also
			_createObservervations: function(){
			  	var self = this;
				var $actualPlayer = $( ABoo.NewHeadlessFlashPlayerSingleton.sharedInstance()._headlessFlashOb._observableSwf );
				$actualPlayer.bind( this._watchableEvents, function( e ) {
					self.handleHeadlessFlashPlayerEvent(e.type);
				});
			},

			_killObservations: function() {
				var $actualPlayer = $( ABoo.NewHeadlessFlashPlayerSingleton.sharedInstance()._headlessFlashOb._observableSwf );
				$actualPlayer.unbind( this._watchableEvents );
			},

			handleHeadlessFlashPlayerEvent: function( eventName ) {
				//console.log("Mofo! got an event " + eventName );
				this._stateMachine.processInputSignal( eventName );
			},

			buffered: function() {
				return ABoo.NewHeadlessFlashPlayerSingleton.sharedInstance().buffered();
			},

			loadedDegrees: function() {
				return ABoo.NewHeadlessFlashPlayerSingleton.sharedInstance().loadedDegrees();
			},

			playedDegrees: function() {
				return ABoo.NewHeadlessFlashPlayerSingleton.sharedInstance().playedDegrees();
			},

			play: function() {
				return ABoo.NewHeadlessFlashPlayerSingleton.sharedInstance().play();
			},

			pause: function() {
				return ABoo.NewHeadlessFlashPlayerSingleton.sharedInstance().pause();
			},

			setCurrentTime: function( secs ) {
				ABoo.NewHeadlessFlashPlayerSingleton.sharedInstance().setCurrentTime(secs);
			}
		});


		/*
		 * Small Player with canvas front-end (flash backend)
		*/
		#{_.qualifiedJsClassName} = ABoo.SCView.extend({

			_flashPlayerBackend: undefined,
			_canvas$: undefined,
			_hooCanvas: undefined,
			_placeHolder$: undefined,
			_smallPlayerFrontEnd: undefined,

			/* properties to bind to. neccesary? */
			_ready: false,
			_loadProgress: 0,
			_playProgress: 0,
			_busyFlag: false,

			didInsertElement: function() {
				this._super();

				var noJsAnchor$ = this.getFirstDomItemOfType("a");
				noJsAnchor$.remove();

				this._placeHolder$ = this.getFirstDomItemOfType("img");
				this._flashPlayerBackend = ABoo.NewHeadlessFlashPlayerBackend.create( {_controller:this, _mp3URL:this.json.mp3Url} );
			},

			mouseUp: function(ev$) {

				// TODO: this is the pits..
				if( this._flashPlayerBackend._state == false ) {
					if( this._placeHolder$ ) {
						this._flashPlayerBackend._attachToPage( this._placeHolder$ );
					}
				}
			},


			// can we draw the playbutton?
			showPlayerGUI: function() {

				SC.RunLoop.begin();

				this._hooCanvas = ABoo.HooCanvas.newProgrammaticCanvas();

				// remove the image and insert the canvas
				this._hooCanvas.swapInFor( this._placeHolder$ );

				// TODO: not how we will size it, but just to make it visible for now
				this._hooCanvas._setSize(200,200);

				// At last! we have found the bit where the whole scheme fails!
				var thePlayButtonJson = { "percentOfCanvas":0.7,
											"javascriptActions":{"mouseClickAction":{"action_taget":this, "action_event":["playClickAction", "pauseClickAction"], "action_arg":null, "actionIsAsync":true}}
										};
				var theRadialProgressJson = { "outerRad":0.95, "innerRad":0.85 };


				var radialProgress = ABoo.HooRadialProgress.create( {json:theRadialProgressJson, _hooCanvas: this._hooCanvas } );
				var playPause = ABoo.HooPlayPauseButton.create( {json:thePlayButtonJson, _hooCanvas: this._hooCanvas } );
				console.warn("created radial "+radialProgress+" and play "+playPause);
				this._smallPlayerFrontEnd = ABoo.SmallPlayerPlayButton.create( {_radialProgress:radialProgress , _playPauseButton:playPause });

				// TODO: dont forget to clean these up
				this.addObserver('_loadProgress', radialProgress, radialProgress.loadDidChange );
				this.addObserver('_playProgress', radialProgress, radialProgress.playDidChange );
				this.addObserver('_busyFlag', radialProgress, radialProgress.busyDidChange );
				this.addObserver('_ready', playPause, 'enabledDidChange' )

				radialProgress.setupDidComplete();
				playPause.setupDidComplete();
				this._smallPlayerFrontEnd.setupDidComplete();

				SC.RunLoop.end();
			},

			hidePlayerGUI: function() {

				if(this._canvas$) {

					var radialProgress = this._smallPlayerFrontEnd._radialProgress;
					var playPause = this._smallPlayerFrontEnd._playPauseButton;

					this.removeObserver('_loadProgress', radialProgress, radialProgress.loadDidChange );
					this.removeObserver('_playProgress', radialProgress, radialProgress.playDidChange );
					this.removeObserver('_busyFlag', radialProgress, radialProgress.busyDidChange );
					this.removeObserver('_ready', playPause, 'enabledDidChange' )

					// TODO: not sure we will create and destroy the canvas each time
					this._hooCanvas.removeAllSubviews();

					//TODO: put back the image
					this._canvas$.replaceWith( this._placeHolder$ );
					this._canvas$ = null;
				}
			},

			/* state machine events */
			ready: function() {
				//not needed? this.set('_ready', true );
				//_guiSprite.setPlayButtonActions(/* fill in args */);

				// it shows ready too soon!!!!
			},
			durationchange: function() {
				console.log("durationchange" );
				this.set('_busyFlag', false);
			},

			// TODO: boiler plate - move
			animateLoadProgress: function( from, to ) {

				//var fromProgressVal = { progress: from };
				this.fakeLoadProgress = from;	// we need the fake because i dont think we can stop $animate directly setting some value, and we need to make sure the setter is called for the real property that we want to set
				var toLoadProgressVal = { fakeLoadProgress: to };
				var self = this;
				jQuery(this).animate( toLoadProgressVal, {
					duration: 1000,
					step: function(now, fx) {
						// console.log("Anim: "+fx.elem.id + ' ' + fx.prop + ': ' + now);
						self.set('_loadProgress', now );
					},
					queue: false
				});
			},

			// TODO: boiler plate - move
			animatePlayProgress: function( from, to ) {
				//var fromProgressVal = { progress: from };
				this.fakePlayProgress = from;	// we need the fake because i dont think we can stop $animate directly setting some value, and we need to make sure the setter is called for the real property that we want to set
				var toPlayProgressVal = { fakePlayProgress: to };
				var self = this;
				jQuery(this).animate( toPlayProgressVal, {
					duration: 1000,
					step: function(now, fx) {
						//console.log("Anim: "+fx.elem.id + ' ' + fx.prop + ': ' + now);
						self.set('_playProgress', now );
					},
					queue: false
				});
			},

			// Beacuse the button action is specified as 'async' it will not automatically show the next state
			// when clicked, we change it when audio player statemachine tells us too
			_showPlay: function() {
				this._smallPlayerFrontEnd._playPauseButton._buttonSMControl.sendEvent( "ev_showState1" );
			},

			_showPause: function() {
				this._smallPlayerFrontEnd._playPauseButton._buttonSMControl.sendEvent( "ev_showState2" );
			},

			_showDisabled: function() {
				this._smallPlayerFrontEnd._playPauseButton._buttonSMControl.sendEvent( "ev_showState1" );
			},

			progressupdate: function() {
				var loadedDegrees = this._loadProgress;
				var actualLoadedDegrees = this._flashPlayerBackend.loadedDegrees();
				if( actualLoadedDegrees > 0 ) {
					this.set('_busyFlag', false);
					console.log("hide stalled");
				}
				this.animateLoadProgress( loadedDegrees, actualLoadedDegrees );
			},

			timeupdate: function() {
				this.animatePlayProgress( this._playProgress, this._flashPlayerBackend.playedDegrees() );
			},

			/* loading commands */
			cmd_showEmptyLoader: function() {
				jQuery(this).stop();
				this.set('_loadProgress', 0);
				this.set('_playProgress', 0);
				this.set('_busyFlag', false);
			},
			cmd_showStalledLoader: function() {
				this.set('_busyFlag', true);
				console.log("show stalled "+this._flashPlayerBackend.loadedDegrees());
			},
			cmd_showLoadingLoader: function() {
				this.set('_busyFlag', true);
			},

			//cmd_showFinishedLoader: function() {
			//	this.animateLoadProgress( this._loadProgress, 360 );
			//	this.set('_busyFlag', false);
			//},
			//cmd_showResettingLoader: function() {
			//},

			cmd_showErrorLoader: function() {
				this._showDisabled();
				this.set('_busyFlag', true);
			},

			/* playing commands */
			cmd_showEmptyPlayer: function() {
				this._showDisabled();
			},
			cmd_showStoppedPlayer: function() {
				this._showPlay();
			},
			cmd_showWaitingPlayer: function() {
				this.set('_busyFlag', true);
				console.log("show stalled 2");
			},
			cmd_hideWaitingPlayer: function() {
				this.set('_busyFlag', false);
				console.log("hide stalled 2");
			},
			cmd_showPlayingPlayer: function() {
				this._showPause();
			},
			cmd_showFinishedPlayer: function() {
				jQuery(this).stop();
				this.set( '_playProgress', 0 );

				// need this to reset

				//this._flashPlayerBackend.handleHeadlessFlashPlayerEvent('pause');
				this._flashPlayerBackend.pause();
				this._flashPlayerBackend.setCurrentTime(0);
				//this._showPlay();

				// maybe stop goes here?
			},
			cmd_showErrorPlayer: function() {
				this._showDisabled();
			},

			/* Button Actions */
			playClickAction: function() {
				this._flashPlayerBackend.play();
			},
			pauseClickAction: function() {
				this._flashPlayerBackend.pause();
			}

		});


